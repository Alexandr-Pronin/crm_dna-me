<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 07ea8b62-5c24-41d3-a6aa-3f17aab72875 (2026-01-22 11:32Z) -->

# Kampagnen-Routendatei (2026-01-22 11:32Z)

_**User (2026-01-22 09:18Z)**_

Implement the following to-dos from the plan (the plan is attached for your reference). Do NOT edit the plan file itself.

You have been assigned the following 1 to-do(s) with IDs: campaigns-routes

1. [campaigns-routes] Erstelle src/api/routes/campaigns.ts fur Campaign Management

These to-dos have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the assigned to-dos.

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
Der Benutzer möchte, dass ich die Campaign Management API Routes implementiere. Laut dem Plan fehlt eine `src/api/routes/campaigns.ts` Datei, obwohl die `campaigns` Tabelle bereits im Schema existiert.

Ich sollte zuerst:
1. Das Datenbank-Schema für die `campaigns` Tabelle anschauen
2. Die bestehenden Route-Dateien analysieren, um den Code-Stil zu verstehen
3. Die Campaign Routes implementieren

Lass mich zuerst die relevanten Dateien lesen.</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Erstelle src/api/routes/campaigns.ts für Campaign Management

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\migrations\1737475200000_initial-schema.sql</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\api\routes\leads.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Ich habe jetzt:

1. Das DB-Schema für die campaigns Tabelle:
```sql
CREATE TABLE campaigns (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name            VARCHAR(255) NOT NULL,
    campaign_type   VARCHAR(50),
    status          VARCHAR(50) DEFAULT 'draft',
    budget          DECIMAL(10,2),
    spent           DECIMAL(10,2) DEFAULT 0,
    currency        VARCHAR(3) DEFAULT 'EUR',
    utm_source      VARCHAR(100),
    utm_medium      VARCHAR(100),
    utm_campaign    VARCHAR(100) UNIQUE,
    start_date      DATE,
    end_date        DATE,
    leads_generated INTEGER DEFAULT 0,
    deals_created   INTEGER DEFAULT 0,
    revenue_attributed DECIMAL(12,2) DEFAULT 0,
    metadata        JSONB DEFAULT '{}',
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    updated_at      TIMESTAMPTZ DEFAULT NOW()
);
```

2. Der Code-Stil für Routes basierend auf `leads.ts`

Ich muss jetzt:
1. Zuerst schauen, ob es bestehende Schemas gibt
2. Den campaigns.ts Route erstellen

Lass mich die bestehenden Schemas checken und dann eine campaigns.ts erstellen.</details></think>

---

Ich sehe, dass die Route-Dateien bereits existieren. Lass mich prüfen, ob es bereits ein Schema für Campaigns gibt und wie die bestehenden Routes registriert werden:

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

Could not find file 'e:\dname\crm_dna-me\src\api\routes\index.ts' in the workspace.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\types\index.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Ich sehe, dass:
1. Es bereits eine `Campaign` Interface in `src/types/index.ts` gibt
2. Die Routes existieren, aber ich muss schauen, wie sie in die Haupt-App registriert werden. Lass mich das Server-Setup finden.</details></think>

---

Perfekt! Die `Campaign` Typen existieren bereits. Ich muss jetzt schauen, wie die Routes registriert werden, und dann die `campaigns.ts` Route erstellen:

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "Wo werden die API Routes registriert und wie wird Fastify konfiguriert?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/index.ts` | L55 |
| `src/index.ts` | L119-177 |
| `src/index.ts` | L152-232 |
| `src/config/index.ts` | L6-68 |
| `src/index.ts` | L186-232 |
| `src/config/index.ts` | L85-137 |
| `src/api/routes/leads.ts` | L57-808 |
| `src/api/routes/routing.ts` | L27-286 |
| `src/api/middleware/apiKey.ts` | L55 |
| `src/api/routes/events.ts` | L18-355 |
| `src/workers/index.ts` | L21-120 |
| `src/index.ts` | L91-129 |
| `src/index.ts` | L50-91 |
| `src/api/middleware/errorHandler.ts` | L26-111 |
| `src/index.ts` | L68-102 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\api\routes\deals.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt habe ich ein klares Bild vom Code-Stil. Ich muss:
1. Eine `campaigns.ts` Route-Datei erstellen
2. Die Route in `src/index.ts` registrieren

Die Route-Datei sollte die Standard-CRUD-Operationen unterstützen:
- GET /campaigns - Liste aller Campaigns mit Filtern und Pagination
- GET /campaigns/:id - Einzelne Campaign abrufen
- POST /campaigns - Neue Campaign erstellen
- PATCH /campaigns/:id - Campaign aktualisieren
- DELETE /campaigns/:id - Campaign löschen
- Evtl. GET /campaigns/:id/stats - Campaign-Statistiken
- Evtl. GET /campaigns/:id/leads - Leads einer Campaign

Basierend auf dem Schema:
```sql
CREATE TABLE campaigns (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name            VARCHAR(255) NOT NULL,
    campaign_type   VARCHAR(50),
    status          VARCHAR(50) DEFAULT 'draft',
    budget          DECIMAL(10,2),
    spent           DECIMAL(10,2) DEFAULT 0,
    currency        VARCHAR(3) DEFAULT 'EUR',
    utm_source      VARCHAR(100),
    utm_medium      VARCHAR(100),
    utm_campaign    VARCHAR(100) UNIQUE,
    start_date      DATE,
    end_date        DATE,
    leads_generated INTEGER DEFAULT 0,
    deals_created   INTEGER DEFAULT 0,
    revenue_attributed DECIMAL(12,2) DEFAULT 0,
    metadata        JSONB DEFAULT '{}',
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    updated_at      TIMESTAMPTZ DEFAULT NOW()
);
```

Und dem Type:
```typescript
export interface Campaign {
  id: string;
  name: string;
  campaign_type?: string;
  status: CampaignStatus;
  budget?: number;
  spent: number;
  currency: string;
  utm_source?: string;
  utm_medium?: string;
  utm_campaign?: string;
  start_date?: Date;
  end_date?: Date;
  leads_generated: number;
  deals_created: number;
  revenue_attributed: number;
  metadata: Record<string, unknown>;
  created_at: Date;
  updated_at: Date;
}
```

Ich werde die Datei jetzt erstellen und anschließend in index.ts registrieren.</details></think>

---

Ich habe jetzt ein klares Bild. Ich werde die `campaigns.ts` Route erstellen und sie in `src/index.ts` registrieren:

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: e:\dname\crm_dna-me\src\api\routes\campaigns.ts</summary>

**Chunk 1**
Lines added: 1050, lines removed: 1

```diff
@@ -1,1 +1,1050 @@
- 
+ // =============================================================================
+ // src/api/routes/campaigns.ts
+ // Campaign Management API Routes
+ // =============================================================================
+ 
+ import type { FastifyInstance } from 'fastify';
+ import { z } from 'zod';
+ import { validateApiKey } from '../middleware/apiKey.js';
+ import { db } from '../../db/index.js';
+ import { ValidationError, NotFoundError } from '../../errors/index.js';
+ import type { Campaign, CampaignStatus, PaginatedResponse } from '../../types/index.js';
+ 
+ // =============================================================================
+ // Zod Schemas
+ // =============================================================================
+ 
+ const createCampaignSchema = z.object({
+   name: z.string().min(1).max(255),
+   campaign_type: z.string().max(50).optional(),
+   status: z.enum(['draft', 'active', 'paused', 'completed']).default('draft'),
+   budget: z.number().min(0).optional(),
+   currency: z.string().length(3).default('EUR'),
+   utm_source: z.string().max(100).optional(),
+   utm_medium: z.string().max(100).optional(),
+   utm_campaign: z.string().max(100).optional(),
+   start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
+   end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
+   metadata: z.record(z.unknown()).optional()
+ });
+ 
+ const updateCampaignSchema = z.object({
+   name: z.string().min(1).max(255).optional(),
+   campaign_type: z.string().max(50).nullable().optional(),
+   status: z.enum(['draft', 'active', 'paused', 'completed']).optional(),
+   budget: z.number().min(0).nullable().optional(),
+   spent: z.number().min(0).optional(),
+   currency: z.string().length(3).optional(),
+   utm_source: z.string().max(100).nullable().optional(),
+   utm_medium: z.string().max(100).nullable().optional(),
+   utm_campaign: z.string().max(100).nullable().optional(),
+   start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional(),
+   end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional(),
+   metadata: z.record(z.unknown()).optional()
+ });
+ 
+ const campaignFiltersSchema = z.object({
+   status: z.enum(['draft', 'active', 'paused', 'completed']).optional(),
+   campaign_type: z.string().optional(),
+   search: z.string().optional(),
+   utm_source: z.string().optional(),
+   utm_medium: z.string().optional(),
+   start_after: z.string().datetime().optional(),
+   start_before: z.string().datetime().optional(),
+   end_after: z.string().datetime().optional(),
+   end_before: z.string().datetime().optional(),
+   min_budget: z.coerce.number().min(0).optional(),
+   max_budget: z.coerce.number().optional(),
+   page: z.coerce.number().int().min(1).default(1),
+   limit: z.coerce.number().int().min(1).max(100).default(20),
+   sort_by: z.enum(['created_at', 'updated_at', 'name', 'start_date', 'end_date', 'budget', 'leads_generated', 'revenue_attributed']).default('created_at'),
+   sort_order: z.enum(['asc', 'desc']).default('desc')
+ });
+ 
+ const campaignIdParamSchema = z.object({
+   id: z.string().uuid()
+ });
+ 
+ // =============================================================================
+ // Type Definitions
+ // =============================================================================
+ 
+ type CreateCampaignInput = z.infer&lt;typeof createCampaignSchema&gt;;
+ type UpdateCampaignInput = z.infer&lt;typeof updateCampaignSchema&gt;;
+ type CampaignFiltersInput = z.infer&lt;typeof campaignFiltersSchema&gt;;
+ 
+ interface IdParams {
+   id: string;
+ }
+ 
+ interface CampaignResponse {
+   id: string;
+   name: string;
+   campaign_type: string | null;
+   status: CampaignStatus;
+   budget: number | null;
+   spent: number;
+   currency: string;
+   utm_source: string | null;
+   utm_medium: string | null;
+   utm_campaign: string | null;
+   start_date: string | null;
+   end_date: string | null;
+   leads_generated: number;
+   deals_created: number;
+   revenue_attributed: number;
+   metadata: Record&lt;string, unknown&gt;;
+   created_at: string;
+   updated_at: string;
+ }
+ 
+ interface CampaignStats {
+   total_leads: number;
+   total_deals: number;
+   total_revenue: number;
+   conversion_rate: number;
+   cost_per_lead: number | null;
+   roi: number | null;
+ }
+ 
+ // =============================================================================
+ // Helper Functions
+ // =============================================================================
+ 
+ function transformCampaignResponse(campaign: Campaign): CampaignResponse {
+   return {
+     id: campaign.id,
+     name: campaign.name,
+     campaign_type: campaign.campaign_type ?? null,
+     status: campaign.status,
+     budget: campaign.budget ?? null,
+     spent: campaign.spent,
+     currency: campaign.currency,
+     utm_source: campaign.utm_source ?? null,
+     utm_medium: campaign.utm_medium ?? null,
+     utm_campaign: campaign.utm_campaign ?? null,
+     start_date: campaign.start_date?.toISOString?.().split('T')[0] ?? (campaign.start_date as unknown as string) ?? null,
+     end_date: campaign.end_date?.toISOString?.().split('T')[0] ?? (campaign.end_date as unknown as string) ?? null,
+     leads_generated: campaign.leads_generated,
+     deals_created: campaign.deals_created,
+     revenue_attributed: campaign.revenue_attributed,
+     metadata: campaign.metadata ?? {},
+     created_at: campaign.created_at?.toISOString?.() ?? (campaign.created_at as unknown as string),
+     updated_at: campaign.updated_at?.toISOString?.() ?? (campaign.updated_at as unknown as string)
+   };
+ }
+ 
+ // =============================================================================
+ // Database Operations
+ // =============================================================================
+ 
+ async function getCampaignById(id: string): Promise&lt;Campaign&gt; {
+   const result = await db.query&lt;Campaign&gt;(
+     'SELECT * FROM campaigns WHERE id = $1',
+     [id]
+   );
+   
+   if (result.rows.length === 0) {
+     throw new NotFoundError('Campaign not found', { campaignId: id });
+   }
+   
+   return result.rows[0];
+ }
+ 
+ async function searchCampaigns(filters: CampaignFiltersInput): Promise&lt;PaginatedResponse&lt;Campaign&gt;&gt; {
+   const conditions: string[] = [];
+   const params: unknown[] = [];
+   let paramIndex = 1;
+   
+   if (filters.status) {
+     conditions.push(&#96;status = $${paramIndex++}&#96;);
+     params.push(filters.status);
+   }
+   
+   if (filters.campaign_type) {
+     conditions.push(&#96;campaign_type = $${paramIndex++}&#96;);
+     params.push(filters.campaign_type);
+   }
+   
+   if (filters.search) {
+     conditions.push(&#96;(name ILIKE $${paramIndex} OR utm_campaign ILIKE $${paramIndex})&#96;);
+     params.push(&#96;%${filters.search}%&#96;);
+     paramIndex++;
+   }
+   
+   if (filters.utm_source) {
+     conditions.push(&#96;utm_source = $${paramIndex++}&#96;);
+     params.push(filters.utm_source);
+   }
+   
+   if (filters.utm_medium) {
+     conditions.push(&#96;utm_medium = $${paramIndex++}&#96;);
+     params.push(filters.utm_medium);
+   }
+   
+   if (filters.start_after) {
+     conditions.push(&#96;start_date &gt;= $${paramIndex++}&#96;);
+     params.push(filters.start_after);
+   }
+   
+   if (filters.start_before) {
+     conditions.push(&#96;start_date &lt;= $${paramIndex++}&#96;);
+     params.push(filters.start_before);
+   }
+   
+   if (filters.end_after) {
+     conditions.push(&#96;end_date &gt;= $${paramIndex++}&#96;);
+     params.push(filters.end_after);
+   }
+   
+   if (filters.end_before) {
+     conditions.push(&#96;end_date &lt;= $${paramIndex++}&#96;);
+     params.push(filters.end_before);
+   }
+   
+   if (filters.min_budget !== undefined) {
+     conditions.push(&#96;budget &gt;= $${paramIndex++}&#96;);
+     params.push(filters.min_budget);
+   }
+   
+   if (filters.max_budget !== undefined) {
+     conditions.push(&#96;budget &lt;= $${paramIndex++}&#96;);
+     params.push(filters.max_budget);
+   }
+   
+   const whereClause = conditions.length &gt; 0 ? &#96;WHERE ${conditions.join(' AND ')}&#96; : '';
+   
+   // Count total
+   const countResult = await db.query&lt;{ count: string }&gt;(
+     &#96;SELECT COUNT(*) as count FROM campaigns ${whereClause}&#96;,
+     params
+   );
+   const total = parseInt(countResult.rows[0].count, 10);
+   
+   // Get paginated results
+   const offset = (filters.page - 1) * filters.limit;
+   const orderBy = filters.sort_by;
+   const orderDir = filters.sort_order.toUpperCase();
+   
+   const dataResult = await db.query&lt;Campaign&gt;(
+     &#96;SELECT * FROM campaigns ${whereClause} 
+      ORDER BY ${orderBy} ${orderDir}
+      LIMIT $${paramIndex++} OFFSET $${paramIndex}&#96;,
+     [...params, filters.limit, offset]
+   );
+   
+   const totalPages = Math.ceil(total / filters.limit);
+   
+   return {
+     data: dataResult.rows,
+     pagination: {
+       page: filters.page,
+       limit: filters.limit,
+       total,
+       total_pages: totalPages,
+       has_next: filters.page &lt; totalPages,
+       has_prev: filters.page &gt; 1
+     }
+   };
+ }
+ 
+ async function createCampaign(input: CreateCampaignInput): Promise&lt;Campaign&gt; {
+   const result = await db.query&lt;Campaign&gt;(
+     &#96;INSERT INTO campaigns (
+       name, campaign_type, status, budget, currency,
+       utm_source, utm_medium, utm_campaign, start_date, end_date, metadata
+     ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
+     RETURNING *&#96;,
+     [
+       input.name,
+       input.campaign_type ?? null,
+       input.status,
+       input.budget ?? null,
+       input.currency,
+       input.utm_source ?? null,
+       input.utm_medium ?? null,
+       input.utm_campaign ?? null,
+       input.start_date ?? null,
+       input.end_date ?? null,
+       input.metadata ?? {}
+     ]
+   );
+   
+   return result.rows[0];
+ }
+ 
+ async function updateCampaign(id: string, input: UpdateCampaignInput): Promise&lt;Campaign&gt; {
+   // First, verify campaign exists
+   await getCampaignById(id);
+   
+   const updates: string[] = [];
+   const params: unknown[] = [];
+   let paramIndex = 1;
+   
+   if (input.name !== undefined) {
+     updates.push(&#96;name = $${paramIndex++}&#96;);
+     params.push(input.name);
+   }
+   
+   if (input.campaign_type !== undefined) {
+     updates.push(&#96;campaign_type = $${paramIndex++}&#96;);
+     params.push(input.campaign_type);
+   }
+   
+   if (input.status !== undefined) {
+     updates.push(&#96;status = $${paramIndex++}&#96;);
+     params.push(input.status);
+   }
+   
+   if (input.budget !== undefined) {
+     updates.push(&#96;budget = $${paramIndex++}&#96;);
+     params.push(input.budget);
+   }
+   
+   if (input.spent !== undefined) {
+     updates.push(&#96;spent = $${paramIndex++}&#96;);
+     params.push(input.spent);
+   }
+   
+   if (input.currency !== undefined) {
+     updates.push(&#96;currency = $${paramIndex++}&#96;);
+     params.push(input.currency);
+   }
+   
+   if (input.utm_source !== undefined) {
+     updates.push(&#96;utm_source = $${paramIndex++}&#96;);
+     params.push(input.utm_source);
+   }
+   
+   if (input.utm_medium !== undefined) {
+     updates.push(&#96;utm_medium = $${paramIndex++}&#96;);
+     params.push(input.utm_medium);
+   }
+   
+   if (input.utm_campaign !== undefined) {
+     updates.push(&#96;utm_campaign = $${paramIndex++}&#96;);
+     params.push(input.utm_campaign);
+   }
+   
+   if (input.start_date !== undefined) {
+     updates.push(&#96;start_date = $${paramIndex++}&#96;);
+     params.push(input.start_date);
+   }
+   
+   if (input.end_date !== undefined) {
+     updates.push(&#96;end_date = $${paramIndex++}&#96;);
+     params.push(input.end_date);
+   }
+   
+   if (input.metadata !== undefined) {
+     updates.push(&#96;metadata = $${paramIndex++}&#96;);
+     params.push(input.metadata);
+   }
+   
+   if (updates.length === 0) {
+     return getCampaignById(id);
+   }
+   
+   params.push(id);
+   
+   const result = await db.query&lt;Campaign&gt;(
+     &#96;UPDATE campaigns SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *&#96;,
+     params
+   );
+   
+   return result.rows[0];
+ }
+ 
+ async function deleteCampaign(id: string): Promise&lt;void&gt; {
+   // First, verify campaign exists
+   await getCampaignById(id);
+   
+   await db.query('DELETE FROM campaigns WHERE id = $1', [id]);
+ }
+ 
+ async function getCampaignStats(id: string): Promise&lt;CampaignStats&gt; {
+   const campaign = await getCampaignById(id);
+   
+   // Calculate additional stats from related data
+   const leadsResult = await db.query&lt;{ count: string }&gt;(
+     &#96;SELECT COUNT(*) as count FROM leads 
+      WHERE first_touch_campaign = $1 OR last_touch_campaign = $1&#96;,
+     [campaign.utm_campaign]
+   );
+   
+   const dealsResult = await db.query&lt;{ count: string; total_value: string }&gt;(
+     &#96;SELECT COUNT(*) as count, COALESCE(SUM(value), 0) as total_value 
+      FROM deals d
+      JOIN leads l ON d.lead_id = l.id
+      WHERE l.first_touch_campaign = $1 OR l.last_touch_campaign = $1&#96;,
+     [campaign.utm_campaign]
+   );
+   
+   const totalLeads = parseInt(leadsResult.rows[0].count, 10) || campaign.leads_generated;
+   const totalDeals = parseInt(dealsResult.rows[0].count, 10) || campaign.deals_created;
+   const totalRevenue = parseFloat(dealsResult.rows[0].total_value) || campaign.revenue_attributed;
+   
+   const conversionRate = totalLeads &gt; 0 ? (totalDeals / totalLeads) * 100 : 0;
+   const costPerLead = campaign.spent &gt; 0 &amp;&amp; totalLeads &gt; 0 ? campaign.spent / totalLeads : null;
+   const roi = campaign.spent &gt; 0 ? ((totalRevenue - campaign.spent) / campaign.spent) * 100 : null;
+   
+   return {
+     total_leads: totalLeads,
+     total_deals: totalDeals,
+     total_revenue: totalRevenue,
+     conversion_rate: Math.round(conversionRate * 100) / 100,
+     cost_per_lead: costPerLead ? Math.round(costPerLead * 100) / 100 : null,
+     roi: roi ? Math.round(roi * 100) / 100 : null
+   };
+ }
+ 
+ async function getCampaignCountsByStatus(): Promise&lt;Record&lt;CampaignStatus, number&gt;&gt; {
+   const result = await db.query&lt;{ status: CampaignStatus; count: string }&gt;(
+     &#96;SELECT status, COUNT(*) as count FROM campaigns GROUP BY status&#96;
+   );
+   
+   const counts: Record&lt;CampaignStatus, number&gt; = {
+     draft: 0,
+     active: 0,
+     paused: 0,
+     completed: 0
+   };
+   
+   for (const row of result.rows) {
+     counts[row.status] = parseInt(row.count, 10);
+   }
+   
+   return counts;
+ }
+ 
+ // =============================================================================
+ // Route Registration
+ // =============================================================================
+ 
+ export async function campaignsRoutes(fastify: FastifyInstance): Promise&lt;void&gt; {
+ 
+   // ===========================================================================
+   // GET /api/v1/campaigns
+   // ===========================================================================
+   /**
+    * List campaigns with filtering, searching, and pagination.
+    */
+   fastify.get&lt;{
+     Querystring: CampaignFiltersInput;
+   }&gt;(
+     '/campaigns',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'List campaigns with filtering and pagination',
+         tags: ['Campaigns'],
+         querystring: {
+           type: 'object',
+           properties: {
+             status: { type: 'string', enum: ['draft', 'active', 'paused', 'completed'] },
+             campaign_type: { type: 'string' },
+             search: { type: 'string', description: 'Search in name and utm_campaign' },
+             utm_source: { type: 'string' },
+             utm_medium: { type: 'string' },
+             start_after: { type: 'string', format: 'date-time' },
+             start_before: { type: 'string', format: 'date-time' },
+             end_after: { type: 'string', format: 'date-time' },
+             end_before: { type: 'string', format: 'date-time' },
+             min_budget: { type: 'number', minimum: 0 },
+             max_budget: { type: 'number' },
+             page: { type: 'integer', minimum: 1, default: 1 },
+             limit: { type: 'integer', minimum: 1, maximum: 100, default: 20 },
+             sort_by: { type: 'string', enum: ['created_at', 'updated_at', 'name', 'start_date', 'end_date', 'budget', 'leads_generated', 'revenue_attributed'], default: 'created_at' },
+             sort_order: { type: 'string', enum: ['asc', 'desc'], default: 'desc' }
+           }
+         },
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               data: { type: 'array', items: { type: 'object' } },
+               pagination: {
+                 type: 'object',
+                 properties: {
+                   page: { type: 'integer' },
+                   limit: { type: 'integer' },
+                   total: { type: 'integer' },
+                   total_pages: { type: 'integer' },
+                   has_next: { type: 'boolean' },
+                   has_prev: { type: 'boolean' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = campaignFiltersSchema.safeParse(request.query);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid query parameters', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const result = await searchCampaigns(parseResult.data);
+       
+       return {
+         data: result.data.map(transformCampaignResponse),
+         pagination: result.pagination
+       };
+     }
+   );
+ 
+   // ===========================================================================
+   // GET /api/v1/campaigns/stats
+   // ===========================================================================
+   /**
+    * Get campaign statistics summary.
+    */
+   fastify.get(
+     '/campaigns/stats',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Get campaign statistics summary',
+         tags: ['Campaigns'],
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               by_status: {
+                 type: 'object',
+                 properties: {
+                   draft: { type: 'integer' },
+                   active: { type: 'integer' },
+                   paused: { type: 'integer' },
+                   completed: { type: 'integer' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const byStatus = await getCampaignCountsByStatus();
+       
+       return {
+         by_status: byStatus
+       };
+     }
+   );
+ 
+   // ===========================================================================
+   // GET /api/v1/campaigns/:id
+   // ===========================================================================
+   /**
+    * Get a single campaign by ID.
+    */
+   fastify.get&lt;{
+     Params: IdParams;
+   }&gt;(
+     '/campaigns/:id',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Get a campaign by ID',
+         tags: ['Campaigns'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = campaignIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid campaign ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const campaign = await getCampaignById(parseResult.data.id);
+       return transformCampaignResponse(campaign);
+     }
+   );
+ 
+   // ===========================================================================
+   // GET /api/v1/campaigns/:id/stats
+   // ===========================================================================
+   /**
+    * Get detailed statistics for a campaign.
+    */
+   fastify.get&lt;{
+     Params: IdParams;
+   }&gt;(
+     '/campaigns/:id/stats',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Get detailed statistics for a campaign',
+         tags: ['Campaigns'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               total_leads: { type: 'integer' },
+               total_deals: { type: 'integer' },
+               total_revenue: { type: 'number' },
+               conversion_rate: { type: 'number' },
+               cost_per_lead: { type: ['number', 'null'] },
+               roi: { type: ['number', 'null'] }
+             }
+           },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = campaignIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid campaign ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const stats = await getCampaignStats(parseResult.data.id);
+       return stats;
+     }
+   );
+ 
+   // ===========================================================================
+   // POST /api/v1/campaigns
+   // ===========================================================================
+   /**
+    * Create a new campaign.
+    */
+   fastify.post&lt;{
+     Body: CreateCampaignInput;
+   }&gt;(
+     '/campaigns',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Create a new campaign',
+         tags: ['Campaigns'],
+         body: {
+           type: 'object',
+           required: ['name'],
+           properties: {
+             name: { type: 'string', minLength: 1, maxLength: 255 },
+             campaign_type: { type: 'string', maxLength: 50 },
+             status: { type: 'string', enum: ['draft', 'active', 'paused', 'completed'], default: 'draft' },
+             budget: { type: 'number', minimum: 0 },
+             currency: { type: 'string', minLength: 3, maxLength: 3, default: 'EUR' },
+             utm_source: { type: 'string', maxLength: 100 },
+             utm_medium: { type: 'string', maxLength: 100 },
+             utm_campaign: { type: 'string', maxLength: 100 },
+             start_date: { type: 'string', pattern: '^\\d{4}-\\d{2}-\\d{2}$' },
+             end_date: { type: 'string', pattern: '^\\d{4}-\\d{2}-\\d{2}$' },
+             metadata: { type: 'object' }
+           }
+         },
+         response: {
+           201: { type: 'object' },
+           409: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = createCampaignSchema.safeParse(request.body);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid campaign data', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const campaign = await createCampaign(parseResult.data);
+       
+       request.log.info({
+         campaignId: campaign.id,
+         name: campaign.name
+       }, 'Campaign created');
+       
+       return reply.code(201).send(transformCampaignResponse(campaign));
+     }
+   );
+ 
+   // ===========================================================================
+   // PATCH /api/v1/campaigns/:id
+   // ===========================================================================
+   /**
+    * Update an existing campaign.
+    */
+   fastify.patch&lt;{
+     Params: IdParams;
+     Body: UpdateCampaignInput;
+   }&gt;(
+     '/campaigns/:id',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Update a campaign',
+         tags: ['Campaigns'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         body: {
+           type: 'object',
+           properties: {
+             name: { type: 'string', minLength: 1, maxLength: 255 },
+             campaign_type: { type: ['string', 'null'], maxLength: 50 },
+             status: { type: 'string', enum: ['draft', 'active', 'paused', 'completed'] },
+             budget: { type: ['number', 'null'], minimum: 0 },
+             spent: { type: 'number', minimum: 0 },
+             currency: { type: 'string', minLength: 3, maxLength: 3 },
+             utm_source: { type: ['string', 'null'], maxLength: 100 },
+             utm_medium: { type: ['string', 'null'], maxLength: 100 },
+             utm_campaign: { type: ['string', 'null'], maxLength: 100 },
+             start_date: { type: ['string', 'null'], pattern: '^\\d{4}-\\d{2}-\\d{2}$' },
+             end_date: { type: ['string', 'null'], pattern: '^\\d{4}-\\d{2}-\\d{2}$' },
+             metadata: { type: 'object' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const paramResult = campaignIdParamSchema.safeParse(request.params);
+       if (!paramResult.success) {
+         throw new ValidationError('Invalid campaign ID', {
+           validationErrors: paramResult.error.errors
+         });
+       }
+       
+       const bodyResult = updateCampaignSchema.safeParse(request.body);
+       if (!bodyResult.success) {
+         throw new ValidationError('Invalid campaign data', {
+           validationErrors: bodyResult.error.errors
+         });
+       }
+       
+       const campaign = await updateCampaign(paramResult.data.id, bodyResult.data);
+       
+       request.log.info({
+         campaignId: campaign.id
+       }, 'Campaign updated');
+       
+       return transformCampaignResponse(campaign);
+     }
+   );
+ 
+   // ===========================================================================
+   // DELETE /api/v1/campaigns/:id
+   // ===========================================================================
+   /**
+    * Delete a campaign.
+    */
+   fastify.delete&lt;{
+     Params: IdParams;
+   }&gt;(
+     '/campaigns/:id',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Delete a campaign',
+         tags: ['Campaigns'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               success: { type: 'boolean' },
+               message: { type: 'string' }
+             }
+           },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = campaignIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid campaign ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       await deleteCampaign(parseResult.data.id);
+       
+       request.log.info({
+         campaignId: parseResult.data.id
+       }, 'Campaign deleted');
+       
+       return {
+         success: true,
+         message: 'Campaign deleted successfully'
+       };
+     }
+   );
+ 
+   // ===========================================================================
+   // POST /api/v1/campaigns/:id/activate
+   // ===========================================================================
+   /**
+    * Activate a campaign.
+    */
+   fastify.post&lt;{
+     Params: IdParams;
+   }&gt;(
+     '/campaigns/:id/activate',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Activate a campaign',
+         tags: ['Campaigns'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = campaignIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid campaign ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const campaign = await updateCampaign(parseResult.data.id, { status: 'active' });
+       
+       request.log.info({
+         campaignId: campaign.id
+       }, 'Campaign activated');
+       
+       return transformCampaignResponse(campaign);
+     }
+   );
+ 
+   // ===========================================================================
+   // POST /api/v1/campaigns/:id/pause
+   // ===========================================================================
+   /**
+    * Pause a campaign.
+    */
+   fastify.post&lt;{
+     Params: IdParams;
+   }&gt;(
+     '/campaigns/:id/pause',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Pause a campaign',
+         tags: ['Campaigns'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = campaignIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid campaign ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const campaign = await updateCampaign(parseResult.data.id, { status: 'paused' });
+       
+       request.log.info({
+         campaignId: campaign.id
+       }, 'Campaign paused');
+       
+       return transformCampaignResponse(campaign);
+     }
+   );
+ 
+   // ===========================================================================
+   // POST /api/v1/campaigns/:id/complete
+   // ===========================================================================
+   /**
+    * Mark a campaign as completed.
+    */
+   fastify.post&lt;{
+     Params: IdParams;
+   }&gt;(
+     '/campaigns/:id/complete',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Mark a campaign as completed',
+         tags: ['Campaigns'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = campaignIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Invalid campaign ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const campaign = await updateCampaign(parseResult.data.id, { status: 'completed' });
+       
+       request.log.info({
+         campaignId: campaign.id
+       }, 'Campaign completed');
+       
+       return transformCampaignResponse(campaign);
+     }
+   );
+ }
+ 
+ export default campaignsRoutes;
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich die Route in `src/index.ts` registrieren. Ich muss den Import hinzufügen und die Route registrieren.</details></think>

---

Jetzt muss ich die Route in `src/index.ts` registrieren:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\index.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich den Import für campaignsRoutes hinzufügen und die Route registrieren.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: e:\dname\crm_dna-me\src\index.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -23,4 +23,5 @@
  import { reportsRoutes } from './api/routes/reports.js';
  import { teamRoutes } from './api/routes/team.js';
+ import { campaignsRoutes } from './api/routes/campaigns.js';
  import type { HealthCheckResponse } from './types/index.js';
  
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich die Route auch registrieren.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: e:\dname\crm_dna-me\src\index.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -147,4 +147,5 @@
  await fastify.register(reportsRoutes, { prefix: '/api/v1' });
  await fastify.register(teamRoutes, { prefix: '/api/v1' });
+ await fastify.register(campaignsRoutes, { prefix: '/api/v1' });
  
  // =============================================================================
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt sollte ich die Linting-Fehler prüfen.</details></think>

---

Lass mich die Linting-Fehler überprüfen:

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `e:\dname\crm_dna-me\src\api\routes\campaigns.ts`
- `e:\dname\crm_dna-me\src\index.ts`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Keine Linting-Fehler. Die Implementierung ist abgeschlossen. Ich sollte nun die Todo als completed markieren.</details></think>

---

Ausgezeichnet! Keine Linting-Fehler. Die Campaign Management API Routes sind nun vollständig implementiert. Lass mich die Aufgabe als abgeschlossen markieren:

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Erstelle src/api/routes/campaigns.ts für Campaign Management

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Die Aufgabe ist abgeschlossen. Ich sollte dem Benutzer eine Zusammenfassung geben, was erstellt wurde.</details></think>

---

Die Campaign Management API Routes wurden erfolgreich implementiert. Hier ist eine Zusammenfassung:

## ✅ Erstellte Datei: `src/api/routes/campaigns.ts`

### Implementierte Endpoints:

| Endpoint | Methode | Beschreibung |
|----------|---------|--------------|
| `/api/v1/campaigns` | GET | Listet Campaigns mit Filtern, Suche und Pagination |
| `/api/v1/campaigns/stats` | GET | Campaign-Statistiken nach Status |
| `/api/v1/campaigns/:id` | GET | Einzelne Campaign abrufen |
| `/api/v1/campaigns/:id/stats` | GET | Detaillierte Statistiken (Leads, Deals, Revenue, ROI) |
| `/api/v1/campaigns` | POST | Neue Campaign erstellen |
| `/api/v1/campaigns/:id` | PATCH | Campaign aktualisieren |
| `/api/v1/campaigns/:id` | DELETE | Campaign löschen |
| `/api/v1/campaigns/:id/activate` | POST | Campaign aktivieren |
| `/api/v1/campaigns/:id/pause` | POST | Campaign pausieren |
| `/api/v1/campaigns/:id/complete` | POST | Campaign als abgeschlossen markieren |

### Features:

- **Zod-Validierung** für alle Eingaben
- **Pagination** mit konfigurierbarer Seitengröße
- **Filterung** nach Status, Typ, UTM-Parameter, Datum, Budget
- **Suche** in Name und UTM-Campaign
- **Sortierung** nach verschiedenen Feldern
- **Detaillierte Statistiken** inkl. Conversion Rate, Cost-per-Lead und ROI-Berechnung
- **API-Key Authentifizierung** über das bestehende Middleware
- **OpenAPI-Schema** für alle Endpoints

Die Route wurde auch in `src/index.ts` registriert und ist damit sofort einsatzbereit.

---

