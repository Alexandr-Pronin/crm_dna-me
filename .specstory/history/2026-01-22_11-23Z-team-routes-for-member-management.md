<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session aa306068-2bee-4e9e-81ee-b6e1064342e1 (2026-01-22 11:23Z) -->

# Team routes for member management (2026-01-22 11:23Z)

_**User (2026-01-22 09:18Z)**_

Implement the following to-dos from the plan (the plan is attached for your reference). Do NOT edit the plan file itself.

You have been assigned the following 1 to-do(s) with IDs: team-routes

1. [team-routes] Erstelle src/api/routes/team.ts fur Team Member Management

These to-dos have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the assigned to-dos.

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
Der Benutzer möchte, dass ich die Team Member Routes implementiere. Laut dem Plan fehlt `src/api/routes/team.ts` für Team Member Management.

Ich sollte zuerst:
1. Die bestehenden Route-Dateien anschauen, um das Pattern zu verstehen
2. Das Datenbankschema prüfen, um zu sehen, welche Team-bezogenen Tabellen existieren
3. Die Master-Prompts lesen, um die genauen Anforderungen zu verstehen
4. Die Route-Datei erstellen

Lass mich anfangen, indem ich den Todo als "in_progress" markiere und dann die bestehende Codebasis erkunde.</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Erstelle src/api/routes/team.ts für Team Member Management

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\migrations\1737475200000_initial-schema.sql</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\api\routes\leads.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Ich habe jetzt die Datenbankstruktur und ein Beispiel für eine Route-Datei. Ich sehe, dass die `team_members` Tabelle folgende Felder hat:
- id (UUID)
- email (VARCHAR 255, unique)
- name (VARCHAR 255)
- role (VARCHAR 50)
- region (VARCHAR 50)
- is_active (BOOLEAN, default TRUE)
- max_leads (INTEGER, default 50)
- current_leads (INTEGER, default 0)
- created_at (TIMESTAMPTZ)

Ich sollte jetzt:
1. Die Middleware und den Error-Import prüfen
2. Eine passende Schema-Datei erstellen oder die bestehende Struktur prüfen
3. Die Team-Route-Datei erstellen

Lass mich zuerst die Schema-Struktur der anderen Dateien prüfen.</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\api\schemas\leads.ts</summary>

</details>
</tool-use>

---

Could not find file 'e:\dname\crm_dna-me\src\errors\index.js' in the workspace.

---

<think><details><summary>Thought Process</summary>
Es ist wahrscheinlich ein TypeScript-Projekt, also sollte ich nach `index.ts` suchen. Lass mich auch die Typen und die Struktur des Routers prüfen, um zu sehen, wie die Routen registriert werden.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\errors\index.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\types\index.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "Wie werden die API Routes registriert und importiert?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/api/routes/events.ts` | L18-355 |
| `src/api/routes/leads.ts` | L57-808 |
| `src/api/routes/routing.ts` | L27-286 |
| `src/api/routes/events.ts` | L21 |
| `src/api/routes/leads.ts` | L36 |
| `src/api/middleware/apiKey.ts` | L55 |
| `src/api/routes/routing.ts` | L31 |
| `src/api/routes/routing.ts` | L35-288 |
| `src/api/routes/scoring.ts` | L51-472 |
| `src/api/routes/leads.ts` | L101-810 |
| `src/api/routes/scoring.ts` | L36-470 |
| `src/api/routes/scoring.ts` | L45 |
| `src/api/routes/events.ts` | L365-395 |
| `src/api/routes/events.ts` | L23-355 |
| `src/api/routes/.gitkeep` | L1 |

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Ich habe jetzt ein gutes Verständnis der Struktur. Ich sollte auch prüfen, wie die Routen im Server registriert werden. Lass mich das Haupt-Server-Setup finden und dann den Team-Service prüfen, falls einer existiert, und anschließend die Datei erstellen.</details></think>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "Wo werden die Fastify Routes registriert (leadsRoutes, eventsRoutes)?" • **10** results</summary>
            
| File | Lines |
|------|-------|
| `src/index.ts` | L118-175 |
| `src/index.ts` | L54 |
| `src/api/routes/leads.ts` | L57-808 |
| `src/api/routes/events.ts` | L18-355 |
| `src/workers/index.ts` | L18-109 |
| `src/api/routes/leads.ts` | L36 |
| `src/api/routes/events.ts` | L23-355 |
| `src/api/routes/leads.ts` | L99-808 |
| `src/index.ts` | L150-230 |
| `src/api/routes/events.ts` | L21 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "TeamMember" in "e:\dname\crm_dna-me\src\services" • 8 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/services\pipelineRouter.ts` | `TeamMember,` | L19 |
| `src/services\pipelineRouter.ts` | `): Promise<TeamMember \| null> \{` | L217 |
| `src/services\pipelineRouter.ts` | `let owner: TeamMember \| null = null;` | L218 |
| `src/services\pipelineRouter.ts` | `private async getNextAvailableOwner(role: string, region?: string): Promise<TeamMember \| null> \{` | L270 |
| `src/services\pipelineRouter.ts` | `return await db.queryOne<TeamMember>(sql, params);` | L286 |
| `src/services\pipelineRouter.ts` | `private async getLeastLoadedOwner(role: string, region?: string): Promise<TeamMember \| null> \{` | L292 |
| `src/services\pipelineRouter.ts` | `return await db.queryOne<TeamMember>(sql, params);` | L309 |
| `src/services\pipelineRouter.ts` | `owner: TeamMember \| null` | L436 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Ich habe jetzt alle Informationen, die ich brauche:

1. Die Route-Registrierung erfolgt in `src/index.ts`
2. Es gibt bereits einen `TeamMember` Typ in `src/types/index.ts`
3. Die Tabelle `team_members` enthält:
   - id (UUID)
   - email (unique)
   - name
   - role
   - region
   - is_active (default TRUE)
   - max_leads (default 50)
   - current_leads (default 0)
   - created_at

Ich werde jetzt:
1. Eine Schema-Datei für Team erstellen (`src/api/schemas/team.ts`)
2. Die Route-Datei erstellen (`src/api/routes/team.ts`)
3. Die Route im `src/index.ts` registrieren

Lass mich die Dateien erstellen.</details></think>

---

Ich werde jetzt die Team Member Management Routes erstellen. Dazu erstelle ich zuerst das Schema und dann die Route-Datei.

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: e:\dname\crm_dna-me\src\api\schemas\team.ts</summary>

**Chunk 1**
Lines added: 132, lines removed: 1

```diff
@@ -1,1 +1,132 @@
- 
+ // =============================================================================
+ // src/api/schemas/team.ts
+ // Zod Validation Schemas for Team Member Management
+ // =============================================================================
+ 
+ import { z } from 'zod';
+ 
+ // =============================================================================
+ // Enum Schemas
+ // =============================================================================
+ 
+ export const teamRoleSchema = z.enum([
+   'bdr',
+   'ae',
+   'partnership_manager',
+   'marketing_manager',
+   'admin'
+ ]);
+ 
+ // =============================================================================
+ // Create Team Member Schema
+ // =============================================================================
+ 
+ export const createTeamMemberSchema = z.object({
+   email: z.string().email('Ungültige E-Mail-Adresse').max(255),
+   name: z.string().min(1, 'Name ist erforderlich').max(255),
+   role: teamRoleSchema,
+   region: z.string().max(50).optional(),
+   is_active: z.boolean().optional().default(true),
+   max_leads: z.number().int().min(0).max(1000).optional().default(50)
+ });
+ 
+ export type CreateTeamMemberInput = z.infer&lt;typeof createTeamMemberSchema&gt;;
+ 
+ // =============================================================================
+ // Update Team Member Schema
+ // =============================================================================
+ 
+ export const updateTeamMemberSchema = z.object({
+   email: z.string().email('Ungültige E-Mail-Adresse').max(255).optional(),
+   name: z.string().min(1).max(255).optional(),
+   role: teamRoleSchema.optional(),
+   region: z.string().max(50).optional().nullable(),
+   is_active: z.boolean().optional(),
+   max_leads: z.number().int().min(0).max(1000).optional()
+ }).partial();
+ 
+ export type UpdateTeamMemberInput = z.infer&lt;typeof updateTeamMemberSchema&gt;;
+ 
+ // =============================================================================
+ // Team Member Filters Schema
+ // =============================================================================
+ 
+ export const teamMemberFiltersSchema = z.object({
+   // Filters
+   role: teamRoleSchema.optional(),
+   region: z.string().optional(),
+   is_active: z.coerce.boolean().optional(),
+   
+   // Search
+   search: z.string().optional(),
+   
+   // Pagination
+   page: z.coerce.number().int().min(1).default(1),
+   limit: z.coerce.number().int().min(1).max(100).default(20),
+   
+   // Sorting
+   sort_by: z.enum([
+     'created_at',
+     'name',
+     'email',
+     'role',
+     'region',
+     'current_leads'
+   ]).default('name'),
+   sort_order: z.enum(['asc', 'desc']).default('asc')
+ });
+ 
+ export type TeamMemberFiltersInput = z.infer&lt;typeof teamMemberFiltersSchema&gt;;
+ 
+ // =============================================================================
+ // Team Member ID Param Schema
+ // =============================================================================
+ 
+ export const teamMemberIdParamSchema = z.object({
+   id: z.string().uuid('Ungültige Team Member ID')
+ });
+ 
+ export type TeamMemberIdParam = z.infer&lt;typeof teamMemberIdParamSchema&gt;;
+ 
+ // =============================================================================
+ // Team Member Response Types
+ // =============================================================================
+ 
+ export interface TeamMemberResponse {
+   id: string;
+   email: string;
+   name: string;
+   role: string;
+   region: string | null;
+   is_active: boolean;
+   max_leads: number;
+   current_leads: number;
+   created_at: string;
+ }
+ 
+ export interface TeamMemberListResponse {
+   data: TeamMemberResponse[];
+   pagination: {
+     page: number;
+     limit: number;
+     total: number;
+     total_pages: number;
+     has_next: boolean;
+     has_prev: boolean;
+   };
+ }
+ 
+ // =============================================================================
+ // Team Member Stats Response
+ // =============================================================================
+ 
+ export interface TeamMemberStatsResponse {
+   total_members: number;
+   active_members: number;
+   by_role: Record&lt;string, number&gt;;
+   by_region: Record&lt;string, number&gt;;
+   total_capacity: number;
+   total_assigned: number;
+   utilization_percentage: number;
+ }
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt erstelle ich die Team-Route-Datei:</details></think>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: e:\dname\crm_dna-me\src\api\routes\team.ts</summary>

**Chunk 1**
Lines added: 954, lines removed: 1

```diff
@@ -1,1 +1,954 @@
- 
+ // =============================================================================
+ // src/api/routes/team.ts
+ // Team Member Management API Routes
+ // =============================================================================
+ 
+ import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
+ import { validateApiKey } from '../middleware/apiKey.js';
+ import {
+   createTeamMemberSchema,
+   updateTeamMemberSchema,
+   teamMemberFiltersSchema,
+   teamMemberIdParamSchema,
+   type CreateTeamMemberInput,
+   type UpdateTeamMemberInput,
+   type TeamMemberFiltersInput,
+   type TeamMemberResponse,
+   type TeamMemberListResponse,
+   type TeamMemberStatsResponse
+ } from '../schemas/team.js';
+ import { db } from '../../db/index.js';
+ import { ValidationError, NotFoundError, ConflictError } from '../../errors/index.js';
+ import type { TeamMember } from '../../types/index.js';
+ 
+ // =============================================================================
+ // Type Extensions
+ // =============================================================================
+ 
+ interface IdParams {
+   id: string;
+ }
+ 
+ // =============================================================================
+ // Helper Functions
+ // =============================================================================
+ 
+ /**
+  * Transform TeamMember entity to API response format
+  */
+ function transformTeamMemberResponse(member: TeamMember): TeamMemberResponse {
+   return {
+     id: member.id,
+     email: member.email,
+     name: member.name,
+     role: member.role,
+     region: member.region ?? null,
+     is_active: member.is_active,
+     max_leads: member.max_leads,
+     current_leads: member.current_leads,
+     created_at: member.created_at?.toISOString?.() ?? (member.created_at as unknown as string)
+   };
+ }
+ 
+ // =============================================================================
+ // Route Registration
+ // =============================================================================
+ 
+ export async function teamRoutes(fastify: FastifyInstance): Promise&lt;void&gt; {
+ 
+   // ===========================================================================
+   // GET /api/v1/team
+   // ===========================================================================
+   /**
+    * List team members with filtering, searching, and pagination.
+    */
+   fastify.get&lt;{
+     Querystring: TeamMemberFiltersInput;
+     Reply: TeamMemberListResponse;
+   }&gt;(
+     '/team',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'List team members with filtering and pagination',
+         tags: ['Team'],
+         querystring: {
+           type: 'object',
+           properties: {
+             search: { type: 'string', description: 'Search in email and name' },
+             role: { type: 'string', enum: ['bdr', 'ae', 'partnership_manager', 'marketing_manager', 'admin'] },
+             region: { type: 'string' },
+             is_active: { type: 'boolean' },
+             page: { type: 'integer', minimum: 1, default: 1 },
+             limit: { type: 'integer', minimum: 1, maximum: 100, default: 20 },
+             sort_by: { type: 'string', enum: ['created_at', 'name', 'email', 'role', 'region', 'current_leads'], default: 'name' },
+             sort_order: { type: 'string', enum: ['asc', 'desc'], default: 'asc' }
+           }
+         },
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               data: { type: 'array', items: { type: 'object' } },
+               pagination: {
+                 type: 'object',
+                 properties: {
+                   page: { type: 'integer' },
+                   limit: { type: 'integer' },
+                   total: { type: 'integer' },
+                   total_pages: { type: 'integer' },
+                   has_next: { type: 'boolean' },
+                   has_prev: { type: 'boolean' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = teamMemberFiltersSchema.safeParse(request.query);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Ungültige Query-Parameter', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const filters = parseResult.data;
+       const offset = (filters.page - 1) * filters.limit;
+       
+       // Build WHERE clause
+       const conditions: string[] = [];
+       const params: unknown[] = [];
+       let paramIndex = 1;
+       
+       if (filters.search) {
+         conditions.push(&#96;(email ILIKE $${paramIndex} OR name ILIKE $${paramIndex})&#96;);
+         params.push(&#96;%${filters.search}%&#96;);
+         paramIndex++;
+       }
+       
+       if (filters.role) {
+         conditions.push(&#96;role = $${paramIndex}&#96;);
+         params.push(filters.role);
+         paramIndex++;
+       }
+       
+       if (filters.region) {
+         conditions.push(&#96;region = $${paramIndex}&#96;);
+         params.push(filters.region);
+         paramIndex++;
+       }
+       
+       if (filters.is_active !== undefined) {
+         conditions.push(&#96;is_active = $${paramIndex}&#96;);
+         params.push(filters.is_active);
+         paramIndex++;
+       }
+       
+       const whereClause = conditions.length &gt; 0 ? &#96;WHERE ${conditions.join(' AND ')}&#96; : '';
+       
+       // Get total count
+       const countSql = &#96;SELECT COUNT(*) as count FROM team_members ${whereClause}&#96;;
+       const countResult = await db.queryOne&lt;{ count: string }&gt;(countSql, params);
+       const total = parseInt(countResult?.count || '0', 10);
+       
+       // Get paginated results
+       const allowedSortColumns = ['created_at', 'name', 'email', 'role', 'region', 'current_leads'];
+       const sortColumn = allowedSortColumns.includes(filters.sort_by) ? filters.sort_by : 'name';
+       const sortOrder = filters.sort_order === 'desc' ? 'DESC' : 'ASC';
+       
+       const dataSql = &#96;
+         SELECT * FROM team_members 
+         ${whereClause}
+         ORDER BY ${sortColumn} ${sortOrder}
+         LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
+       &#96;;
+       
+       const members = await db.query&lt;TeamMember&gt;(dataSql, [...params, filters.limit, offset]);
+       
+       const totalPages = Math.ceil(total / filters.limit);
+       
+       return {
+         data: members.map(transformTeamMemberResponse),
+         pagination: {
+           page: filters.page,
+           limit: filters.limit,
+           total,
+           total_pages: totalPages,
+           has_next: filters.page &lt; totalPages,
+           has_prev: filters.page &gt; 1
+         }
+       };
+     }
+   );
+ 
+   // ===========================================================================
+   // GET /api/v1/team/stats
+   // ===========================================================================
+   /**
+    * Get team statistics.
+    */
+   fastify.get&lt;{
+     Reply: TeamMemberStatsResponse;
+   }&gt;(
+     '/team/stats',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Get team member statistics',
+         tags: ['Team'],
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               total_members: { type: 'integer' },
+               active_members: { type: 'integer' },
+               by_role: { type: 'object' },
+               by_region: { type: 'object' },
+               total_capacity: { type: 'integer' },
+               total_assigned: { type: 'integer' },
+               utilization_percentage: { type: 'number' }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       // Get counts by role
+       const byRoleSql = &#96;
+         SELECT role, COUNT(*) as count 
+         FROM team_members 
+         WHERE is_active = true 
+         GROUP BY role
+       &#96;;
+       const roleResults = await db.query&lt;{ role: string; count: string }&gt;(byRoleSql);
+       const byRole: Record&lt;string, number&gt; = {};
+       for (const row of roleResults) {
+         byRole[row.role] = parseInt(row.count, 10);
+       }
+       
+       // Get counts by region
+       const byRegionSql = &#96;
+         SELECT COALESCE(region, 'unassigned') as region, COUNT(*) as count 
+         FROM team_members 
+         WHERE is_active = true 
+         GROUP BY region
+       &#96;;
+       const regionResults = await db.query&lt;{ region: string; count: string }&gt;(byRegionSql);
+       const byRegion: Record&lt;string, number&gt; = {};
+       for (const row of regionResults) {
+         byRegion[row.region] = parseInt(row.count, 10);
+       }
+       
+       // Get totals
+       const totalsSql = &#96;
+         SELECT 
+           COUNT(*) as total_members,
+           COUNT(*) FILTER (WHERE is_active = true) as active_members,
+           COALESCE(SUM(max_leads) FILTER (WHERE is_active = true), 0) as total_capacity,
+           COALESCE(SUM(current_leads) FILTER (WHERE is_active = true), 0) as total_assigned
+         FROM team_members
+       &#96;;
+       const totals = await db.queryOne&lt;{
+         total_members: string;
+         active_members: string;
+         total_capacity: string;
+         total_assigned: string;
+       }&gt;(totalsSql);
+       
+       const totalCapacity = parseInt(totals?.total_capacity || '0', 10);
+       const totalAssigned = parseInt(totals?.total_assigned || '0', 10);
+       
+       return {
+         total_members: parseInt(totals?.total_members || '0', 10),
+         active_members: parseInt(totals?.active_members || '0', 10),
+         by_role: byRole,
+         by_region: byRegion,
+         total_capacity: totalCapacity,
+         total_assigned: totalAssigned,
+         utilization_percentage: totalCapacity &gt; 0 
+           ? Math.round((totalAssigned / totalCapacity) * 100 * 100) / 100 
+           : 0
+       };
+     }
+   );
+ 
+   // ===========================================================================
+   // GET /api/v1/team/:id
+   // ===========================================================================
+   /**
+    * Get a single team member by ID.
+    */
+   fastify.get&lt;{
+     Params: IdParams;
+     Reply: TeamMemberResponse;
+   }&gt;(
+     '/team/:id',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Get a team member by ID',
+         tags: ['Team'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = teamMemberIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Ungültige Team Member ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const member = await db.queryOne&lt;TeamMember&gt;(
+         'SELECT * FROM team_members WHERE id = $1',
+         [parseResult.data.id]
+       );
+       
+       if (!member) {
+         throw new NotFoundError('Team Member', parseResult.data.id);
+       }
+       
+       return transformTeamMemberResponse(member);
+     }
+   );
+ 
+   // ===========================================================================
+   // POST /api/v1/team
+   // ===========================================================================
+   /**
+    * Create a new team member.
+    */
+   fastify.post&lt;{
+     Body: CreateTeamMemberInput;
+     Reply: TeamMemberResponse;
+   }&gt;(
+     '/team',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Create a new team member',
+         tags: ['Team'],
+         body: {
+           type: 'object',
+           required: ['email', 'name', 'role'],
+           properties: {
+             email: { type: 'string', format: 'email', maxLength: 255 },
+             name: { type: 'string', minLength: 1, maxLength: 255 },
+             role: { type: 'string', enum: ['bdr', 'ae', 'partnership_manager', 'marketing_manager', 'admin'] },
+             region: { type: 'string', maxLength: 50 },
+             is_active: { type: 'boolean', default: true },
+             max_leads: { type: 'integer', minimum: 0, maximum: 1000, default: 50 }
+           }
+         },
+         response: {
+           201: { type: 'object' },
+           409: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = createTeamMemberSchema.safeParse(request.body);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Ungültige Team Member Daten', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const data = parseResult.data;
+       
+       // Check if email already exists
+       const existing = await db.queryOne&lt;{ id: string }&gt;(
+         'SELECT id FROM team_members WHERE email = $1',
+         [data.email]
+       );
+       
+       if (existing) {
+         throw new ConflictError('Ein Team Member mit dieser E-Mail existiert bereits', {
+           email: data.email
+         });
+       }
+       
+       const sql = &#96;
+         INSERT INTO team_members (email, name, role, region, is_active, max_leads)
+         VALUES ($1, $2, $3, $4, $5, $6)
+         RETURNING *
+       &#96;;
+       
+       const member = await db.queryOne&lt;TeamMember&gt;(sql, [
+         data.email,
+         data.name,
+         data.role,
+         data.region ?? null,
+         data.is_active ?? true,
+         data.max_leads ?? 50
+       ]);
+       
+       if (!member) {
+         throw new Error('Team Member konnte nicht erstellt werden');
+       }
+       
+       request.log.info({
+         teamMemberId: member.id,
+         email: member.email,
+         role: member.role
+       }, 'Team Member erstellt');
+       
+       return reply.code(201).send(transformTeamMemberResponse(member));
+     }
+   );
+ 
+   // ===========================================================================
+   // PATCH /api/v1/team/:id
+   // ===========================================================================
+   /**
+    * Update an existing team member.
+    */
+   fastify.patch&lt;{
+     Params: IdParams;
+     Body: UpdateTeamMemberInput;
+     Reply: TeamMemberResponse;
+   }&gt;(
+     '/team/:id',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Update a team member',
+         tags: ['Team'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         body: {
+           type: 'object',
+           properties: {
+             email: { type: 'string', format: 'email', maxLength: 255 },
+             name: { type: 'string', minLength: 1, maxLength: 255 },
+             role: { type: 'string', enum: ['bdr', 'ae', 'partnership_manager', 'marketing_manager', 'admin'] },
+             region: { type: ['string', 'null'], maxLength: 50 },
+             is_active: { type: 'boolean' },
+             max_leads: { type: 'integer', minimum: 0, maximum: 1000 }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const paramResult = teamMemberIdParamSchema.safeParse(request.params);
+       if (!paramResult.success) {
+         throw new ValidationError('Ungültige Team Member ID', {
+           validationErrors: paramResult.error.errors
+         });
+       }
+       
+       const bodyResult = updateTeamMemberSchema.safeParse(request.body);
+       if (!bodyResult.success) {
+         throw new ValidationError('Ungültige Team Member Daten', {
+           validationErrors: bodyResult.error.errors
+         });
+       }
+       
+       const { id } = paramResult.data;
+       const data = bodyResult.data;
+       
+       // Check if team member exists
+       const existing = await db.queryOne&lt;TeamMember&gt;(
+         'SELECT * FROM team_members WHERE id = $1',
+         [id]
+       );
+       
+       if (!existing) {
+         throw new NotFoundError('Team Member', id);
+       }
+       
+       // Check if email is being changed and if new email already exists
+       if (data.email &amp;&amp; data.email !== existing.email) {
+         const emailExists = await db.queryOne&lt;{ id: string }&gt;(
+           'SELECT id FROM team_members WHERE email = $1 AND id != $2',
+           [data.email, id]
+         );
+         
+         if (emailExists) {
+           throw new ConflictError('Ein Team Member mit dieser E-Mail existiert bereits', {
+             email: data.email
+           });
+         }
+       }
+       
+       // Build update query dynamically
+       const updates: string[] = [];
+       const params: unknown[] = [];
+       let paramIndex = 1;
+       
+       if (data.email !== undefined) {
+         updates.push(&#96;email = $${paramIndex}&#96;);
+         params.push(data.email);
+         paramIndex++;
+       }
+       
+       if (data.name !== undefined) {
+         updates.push(&#96;name = $${paramIndex}&#96;);
+         params.push(data.name);
+         paramIndex++;
+       }
+       
+       if (data.role !== undefined) {
+         updates.push(&#96;role = $${paramIndex}&#96;);
+         params.push(data.role);
+         paramIndex++;
+       }
+       
+       if (data.region !== undefined) {
+         updates.push(&#96;region = $${paramIndex}&#96;);
+         params.push(data.region);
+         paramIndex++;
+       }
+       
+       if (data.is_active !== undefined) {
+         updates.push(&#96;is_active = $${paramIndex}&#96;);
+         params.push(data.is_active);
+         paramIndex++;
+       }
+       
+       if (data.max_leads !== undefined) {
+         updates.push(&#96;max_leads = $${paramIndex}&#96;);
+         params.push(data.max_leads);
+         paramIndex++;
+       }
+       
+       if (updates.length === 0) {
+         return transformTeamMemberResponse(existing);
+       }
+       
+       params.push(id);
+       
+       const sql = &#96;
+         UPDATE team_members 
+         SET ${updates.join(', ')}
+         WHERE id = $${paramIndex}
+         RETURNING *
+       &#96;;
+       
+       const member = await db.queryOne&lt;TeamMember&gt;(sql, params);
+       
+       if (!member) {
+         throw new Error('Team Member konnte nicht aktualisiert werden');
+       }
+       
+       request.log.info({
+         teamMemberId: member.id
+       }, 'Team Member aktualisiert');
+       
+       return transformTeamMemberResponse(member);
+     }
+   );
+ 
+   // ===========================================================================
+   // DELETE /api/v1/team/:id
+   // ===========================================================================
+   /**
+    * Delete a team member.
+    */
+   fastify.delete&lt;{
+     Params: IdParams;
+     Reply: { success: boolean; message: string };
+   }&gt;(
+     '/team/:id',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Delete a team member',
+         tags: ['Team'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               success: { type: 'boolean' },
+               message: { type: 'string' }
+             }
+           },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = teamMemberIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Ungültige Team Member ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const { id } = parseResult.data;
+       
+       // Check if team member exists
+       const existing = await db.queryOne&lt;{ id: string }&gt;(
+         'SELECT id FROM team_members WHERE id = $1',
+         [id]
+       );
+       
+       if (!existing) {
+         throw new NotFoundError('Team Member', id);
+       }
+       
+       // Check if member has assigned leads/deals
+       const assignedDeals = await db.queryOne&lt;{ count: string }&gt;(
+         'SELECT COUNT(*) as count FROM deals WHERE assigned_to = $1',
+         [id]
+       );
+       
+       const assignedTasks = await db.queryOne&lt;{ count: string }&gt;(
+         'SELECT COUNT(*) as count FROM tasks WHERE assigned_to = $1 AND status = $2',
+         [id, 'open']
+       );
+       
+       const dealCount = parseInt(assignedDeals?.count || '0', 10);
+       const taskCount = parseInt(assignedTasks?.count || '0', 10);
+       
+       if (dealCount &gt; 0 || taskCount &gt; 0) {
+         throw new ConflictError(
+           'Team Member kann nicht gelöscht werden, da noch Deals oder offene Tasks zugewiesen sind',
+           {
+             assigned_deals: dealCount,
+             assigned_open_tasks: taskCount
+           }
+         );
+       }
+       
+       await db.query('DELETE FROM team_members WHERE id = $1', [id]);
+       
+       request.log.info({
+         teamMemberId: id
+       }, 'Team Member gelöscht');
+       
+       return {
+         success: true,
+         message: 'Team Member erfolgreich gelöscht'
+       };
+     }
+   );
+ 
+   // ===========================================================================
+   // POST /api/v1/team/:id/deactivate
+   // ===========================================================================
+   /**
+    * Deactivate a team member (soft delete).
+    */
+   fastify.post&lt;{
+     Params: IdParams;
+     Reply: TeamMemberResponse;
+   }&gt;(
+     '/team/:id/deactivate',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Deactivate a team member',
+         tags: ['Team'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = teamMemberIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Ungültige Team Member ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const member = await db.queryOne&lt;TeamMember&gt;(
+         'UPDATE team_members SET is_active = false WHERE id = $1 RETURNING *',
+         [parseResult.data.id]
+       );
+       
+       if (!member) {
+         throw new NotFoundError('Team Member', parseResult.data.id);
+       }
+       
+       request.log.info({
+         teamMemberId: member.id
+       }, 'Team Member deaktiviert');
+       
+       return transformTeamMemberResponse(member);
+     }
+   );
+ 
+   // ===========================================================================
+   // POST /api/v1/team/:id/activate
+   // ===========================================================================
+   /**
+    * Activate a team member.
+    */
+   fastify.post&lt;{
+     Params: IdParams;
+     Reply: TeamMemberResponse;
+   }&gt;(
+     '/team/:id/activate',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Activate a team member',
+         tags: ['Team'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: { type: 'object' },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = teamMemberIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Ungültige Team Member ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const member = await db.queryOne&lt;TeamMember&gt;(
+         'UPDATE team_members SET is_active = true WHERE id = $1 RETURNING *',
+         [parseResult.data.id]
+       );
+       
+       if (!member) {
+         throw new NotFoundError('Team Member', parseResult.data.id);
+       }
+       
+       request.log.info({
+         teamMemberId: member.id
+       }, 'Team Member aktiviert');
+       
+       return transformTeamMemberResponse(member);
+     }
+   );
+ 
+   // ===========================================================================
+   // GET /api/v1/team/:id/workload
+   // ===========================================================================
+   /**
+    * Get workload information for a team member.
+    */
+   fastify.get&lt;{
+     Params: IdParams;
+     Reply: {
+       member: TeamMemberResponse;
+       workload: {
+         current_leads: number;
+         max_leads: number;
+         available_capacity: number;
+         utilization_percentage: number;
+         open_deals: number;
+         open_tasks: number;
+       };
+     };
+   }&gt;(
+     '/team/:id/workload',
+     {
+       preHandler: validateApiKey,
+       schema: {
+         description: 'Get workload information for a team member',
+         tags: ['Team'],
+         params: {
+           type: 'object',
+           required: ['id'],
+           properties: {
+             id: { type: 'string', format: 'uuid' }
+           }
+         },
+         response: {
+           200: {
+             type: 'object',
+             properties: {
+               member: { type: 'object' },
+               workload: {
+                 type: 'object',
+                 properties: {
+                   current_leads: { type: 'integer' },
+                   max_leads: { type: 'integer' },
+                   available_capacity: { type: 'integer' },
+                   utilization_percentage: { type: 'number' },
+                   open_deals: { type: 'integer' },
+                   open_tasks: { type: 'integer' }
+                 }
+               }
+             }
+           },
+           404: {
+             type: 'object',
+             properties: {
+               error: {
+                 type: 'object',
+                 properties: {
+                   code: { type: 'string' },
+                   message: { type: 'string' }
+                 }
+               }
+             }
+           }
+         }
+       }
+     },
+     async (request, reply) =&gt; {
+       const parseResult = teamMemberIdParamSchema.safeParse(request.params);
+       
+       if (!parseResult.success) {
+         throw new ValidationError('Ungültige Team Member ID', {
+           validationErrors: parseResult.error.errors
+         });
+       }
+       
+       const { id } = parseResult.data;
+       
+       const member = await db.queryOne&lt;TeamMember&gt;(
+         'SELECT * FROM team_members WHERE id = $1',
+         [id]
+       );
+       
+       if (!member) {
+         throw new NotFoundError('Team Member', id);
+       }
+       
+       // Get open deals count
+       const dealsResult = await db.queryOne&lt;{ count: string }&gt;(
+         'SELECT COUNT(*) as count FROM deals WHERE assigned_to = $1 AND status = $2',
+         [id, 'open']
+       );
+       
+       // Get open tasks count
+       const tasksResult = await db.queryOne&lt;{ count: string }&gt;(
+         'SELECT COUNT(*) as count FROM tasks WHERE assigned_to = $1 AND status IN ($2, $3)',
+         [id, 'open', 'in_progress']
+       );
+       
+       const openDeals = parseInt(dealsResult?.count || '0', 10);
+       const openTasks = parseInt(tasksResult?.count || '0', 10);
+       
+       return {
+         member: transformTeamMemberResponse(member),
+         workload: {
+           current_leads: member.current_leads,
+           max_leads: member.max_leads,
+           available_capacity: Math.max(0, member.max_leads - member.current_leads),
+           utilization_percentage: member.max_leads &gt; 0 
+             ? Math.round((member.current_leads / member.max_leads) * 100 * 100) / 100 
+             : 0,
+           open_deals: openDeals,
+           open_tasks: openTasks
+         }
+       };
+     }
+   );
+ }
+ 
+ export default teamRoutes;
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich die Route im `src/index.ts` registrieren. Ich sollte die `teamRoutes` importieren und sie mit den anderen Routen registrieren.</details></think>

---

Jetzt registriere ich die Team Routes im Haupt-Server:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: e:\dname\crm_dna-me\src\index.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich:
1. Den Import für teamRoutes hinzufügen
2. Die Route registrieren

Ich werde diese Änderungen mit search_replace durchführen.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: e:\dname\crm_dna-me\src\index.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -22,4 +22,5 @@
  import { gdprRoutes } from './api/routes/gdpr.js';
  import { reportsRoutes } from './api/routes/reports.js';
+ import { teamRoutes } from './api/routes/team.js';
  import type { HealthCheckResponse } from './types/index.js';
  
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt registriere ich die Team-Route im API-Abschnitt:</details></think>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: e:\dname\crm_dna-me\src\index.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -145,4 +145,5 @@
  await fastify.register(gdprRoutes, { prefix: '/api/v1' });
  await fastify.register(reportsRoutes, { prefix: '/api/v1' });
+ await fastify.register(teamRoutes, { prefix: '/api/v1' });
  
  // =============================================================================
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt prüfe ich die Linter-Fehler in allen drei Dateien, die ich erstellt/geändert habe.</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 3 files</summary>
      
Lint paths:

- `e:\dname\crm_dna-me\src\api\routes\team.ts`
- `e:\dname\crm_dna-me\src\api\schemas\team.ts`
- `e:\dname\crm_dna-me\src\index.ts`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Keine Linter-Fehler. Jetzt markiere ich den Todo als erledigt.</details></think>

---

Ausgezeichnet! Alle Dateien wurden erfolgreich erstellt und es gibt keine Linter-Fehler. Lassen Sie mich den Todo als abgeschlossen markieren:

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Erstelle src/api/routes/team.ts für Team Member Management

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Die Aufgabe ist erledigt. Ich habe:1. Die Schema-Datei `src/api/schemas/team.ts` erstellt mit:   - Zod Validierungsschemas für TeamMember   - Create, Update und Filter Schemas   - Response Types2. Die Route-Datei `src/api/routes/team.ts` erstellt mit folgenden Endpoints:   - GET `/api/v1/team` - Liste aller Team Members mit Filtern und Pagination
   - GET `/api/v1/team/stats` - Team-Statistiken   - GET `/api/v1/team/:id` - Einzelnen Team Member abrufen   - POST `/api/v1/team` - Neuen Team Member erstellen   - PATCH `/api/v1/team/:id` - Team Member aktualisieren   - DELETE `/api/v1/team/:id` - Team Member löschen   - POST `/api/v1/team/:id/deactivate` - Team Member deaktivieren   - POST `/api/v1/team/:id/activate` - Team Member aktivieren   - GET `/api/v1/team/:id/workload` - Workload-Informationen3. Die Route im `src/index.ts` registriertAlle Dateien kompilieren ohne Linter-Fehler.</details></think>

---

Die Team Member Management API wurde erfolgreich implementiert. Hier ist eine Zusammenfassung der erstellten Komponenten:

## Erstellte Dateien

### 1. `src/api/schemas/team.ts`
Zod Validierungsschemas für:
- `createTeamMemberSchema` - Validierung für neue Team Members
- `updateTeamMemberSchema` - Validierung für Updates
- `teamMemberFiltersSchema` - Filter- und Pagination-Parameter
- TypeScript Response-Interfaces

### 2. `src/api/routes/team.ts`
Vollständige CRUD-API mit folgenden Endpoints:

| Methode | Endpoint | Beschreibung |
|---------|----------|--------------|
| GET | `/api/v1/team` | Liste aller Team Members mit Filtern, Suche und Pagination |
| GET | `/api/v1/team/stats` | Team-Statistiken (nach Rolle, Region, Auslastung) |
| GET | `/api/v1/team/:id` | Einzelnen Team Member abrufen |
| POST | `/api/v1/team` | Neuen Team Member erstellen |
| PATCH | `/api/v1/team/:id` | Team Member aktualisieren |
| DELETE | `/api/v1/team/:id` | Team Member löschen (mit Prüfung auf zugewiesene Deals/Tasks) |
| POST | `/api/v1/team/:id/deactivate` | Team Member deaktivieren (Soft Delete) |
| POST | `/api/v1/team/:id/activate` | Team Member aktivieren |
| GET | `/api/v1/team/:id/workload` | Workload-Informationen (Kapazität, Auslastung, offene Deals/Tasks) |

### 3. `src/index.ts`
- Import und Registrierung der `teamRoutes` hinzugefügt

Alle Endpoints sind mit:
- API-Key-Authentifizierung geschützt
- Zod-Validierung ausgestattet
- OpenAPI/Swagger Schema-Definitionen versehen
- Deutschen Fehlermeldungen ausgestattet

---

