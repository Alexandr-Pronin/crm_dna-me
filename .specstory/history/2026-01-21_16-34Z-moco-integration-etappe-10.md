<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session e2b73db3-370b-43b7-8b15-a1cee3615559 (2026-01-21 16:34Z) -->

# Moco integration Etappe 10 (2026-01-21 16:34Z)

_**User (2026-01-21 16:20Z)**_

Implement the following to-dos from the plan (the plan is attached for your reference). Do NOT edit the plan file itself.

You have been assigned the following 1 to-do(s) with IDs: etappe-10

1. [etappe-10] Etappe 10: Moco Integration - Moco Service, Sync Worker

These to-dos have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the assigned to-dos.

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
Der Benutzer möchte, dass ich Etappe 10 aus dem Plan implementiere: Moco Integration. Das beinhaltet:
1. Moco Service erstellen
2. Sync Worker erstellen
3. Moco in Deal Service integrieren
4. Integrations Route erstellen
5. Workers Index aktualisieren

Lass mich zuerst den aktuellen Stand des Projekts überprüfen, um zu verstehen, was bereits implementiert ist.</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Etappe 10: Moco Integration - Moco Service, Sync Worker

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: E:\dname\crm_dna-me\docs\DNA_ME_CRM_CURSOR_MASTER_PROMPT_PART2.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Gut, ich habe jetzt die komplette Dokumentation für die Moco Integration. Lass mich jetzt den aktuellen Stand des Projekts überprüfen, insbesondere:
1. Die vorhandene Konfiguration
2. Die vorhandenen Services
3. Die Workers

Ich muss folgendes erstellen:
1. `src/integrations/moco.ts` - MocoService
2. `src/workers/syncWorker.ts` - Sync Worker
3. `src/api/routes/integrations.ts` - Integrations Route
4. Deal Service aktualisieren für Moco Sync
5. Workers Index aktualisieren

Lass mich erstmal die vorhandenen Dateien lesen, um den aktuellen Stand zu verstehen.</details></think>

---

Ich werde jetzt Etappe 10 implementieren: Moco Integration. Lass mich zuerst den aktuellen Stand der relevanten Dateien prüfen.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: E:\dname\crm_dna-me\src\config\index.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: E:\dname\crm_dna-me\src\services\dealService.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: E:\dname\crm_dna-me\src\workers\index.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: E:\dname\crm_dna-me\src\index.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: E:\dname\crm_dna-me\src\types\index.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt habe ich ein gutes Bild vom aktuellen Stand. Ich muss folgendes erstellen:

1. `src/integrations/moco.ts` - MocoService (gemäß Dokumentation)
2. `src/workers/syncWorker.ts` - Sync Worker für Moco
3. `src/api/routes/integrations.ts` - Integrations Routen
4. Workers index.ts aktualisieren

Ich sehe, dass der dealService bereits Moco Sync Jobs queued (queueMocoSync Methode). Das ist gut!

Lass mich auch die config/queues.ts überprüfen um zu sehen, wie die Queues definiert sind.</details></think>

---

Lass mich noch die queues Konfiguration prüfen:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: E:\dname\crm_dna-me\src\config\queues.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Perfekt! Jetzt habe ich alle Informationen, die ich brauche. Ich werde nun folgendes erstellen:

1. `src/integrations/moco.ts` - MocoService
2. `src/workers/syncWorker.ts` - Sync Worker
3. `src/api/routes/integrations.ts` - Integrations Routen
4. `src/workers/index.ts` aktualisieren - Sync Worker hinzufügen
5. `src/index.ts` aktualisieren - integrations Routes registrieren

Lass mich anfangen!</details></think>

---

Ausgezeichnet! Jetzt habe ich alle benötigten Informationen. Ich werde die Moco Integration implementieren:

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: E:\dname\crm_dna-me\src\integrations\moco.ts</summary>

**Chunk 1**
Lines added: 402, lines removed: 1

```diff
@@ -1,1 +1,402 @@
- 
+ // =============================================================================
+ // src/integrations/moco.ts
+ // Moco Integration - German Finance System
+ // =============================================================================
+ 
+ import axios, { AxiosInstance, AxiosError } from 'axios';
+ import { config } from '../config/index.js';
+ 
+ // =============================================================================
+ // Types
+ // =============================================================================
+ 
+ export interface MocoCustomerData {
+   name: string;
+   email?: string;
+   vat_id?: string;
+   address?: string;
+   country?: string;
+   website?: string;
+   phone?: string;
+   info?: string;
+ }
+ 
+ export interface MocoOfferData {
+   customer_id: string;
+   title: string;
+   value: number;
+   items?: MocoOfferItem[];
+   info?: string;
+ }
+ 
+ export interface MocoOfferItem {
+   title: string;
+   quantity: number;
+   unit_price: number;
+   net_total?: number;
+ }
+ 
+ export interface MocoCustomer {
+   id: string;
+   name: string;
+   email?: string;
+   vat_identifier?: string;
+   address?: string;
+   country_code?: string;
+   created_at: string;
+   updated_at: string;
+ }
+ 
+ export interface MocoOffer {
+   id: string;
+   customer_id: string;
+   title: string;
+   date: string;
+   status: string;
+   net_total: number;
+   created_at: string;
+   updated_at: string;
+ }
+ 
+ export interface MocoInvoice {
+   id: string;
+   customer_id: string;
+   offer_id?: string;
+   title: string;
+   status: string;
+   net_total: number;
+   paid_at?: string;
+   created_at: string;
+   updated_at: string;
+ }
+ 
+ // =============================================================================
+ // Error Types
+ // =============================================================================
+ 
+ export class MocoError extends Error {
+   public readonly statusCode: number;
+   public readonly mocoMessage?: string;
+ 
+   constructor(message: string, statusCode: number, mocoMessage?: string) {
+     super(message);
+     this.name = 'MocoError';
+     this.statusCode = statusCode;
+     this.mocoMessage = mocoMessage;
+   }
+ }
+ 
+ // =============================================================================
+ // Moco Service Class
+ // =============================================================================
+ 
+ export class MocoService {
+   private client: AxiosInstance;
+   private apiKey: string;
+   private subdomain: string;
+ 
+   constructor(apiKey?: string, subdomain?: string) {
+     this.apiKey = apiKey || config.moco.apiKey || '';
+     this.subdomain = subdomain || config.moco.subdomain || '';
+ 
+     if (!this.apiKey || !this.subdomain) {
+       console.warn('⚠️ MocoService: API key or subdomain not configured');
+     }
+ 
+     this.client = axios.create({
+       baseURL: &#96;https://${this.subdomain}.mocoapp.com/api/v1&#96;,
+       headers: {
+         'Authorization': &#96;Token token=${this.apiKey}&#96;,
+         'Content-Type': 'application/json'
+       },
+       timeout: 30000 // 30 seconds
+     });
+ 
+     // Add response interceptor for error handling
+     this.client.interceptors.response.use(
+       (response) =&gt; response,
+       (error: AxiosError) =&gt; {
+         const statusCode = error.response?.status || 500;
+         const mocoMessage = (error.response?.data as { message?: string })?.message;
+         
+         throw new MocoError(
+           &#96;Moco API error: ${error.message}&#96;,
+           statusCode,
+           mocoMessage
+         );
+       }
+     );
+   }
+ 
+   // ===========================================================================
+   // Configuration Check
+   // ===========================================================================
+ 
+   isConfigured(): boolean {
+     return !!(this.apiKey &amp;&amp; this.subdomain);
+   }
+ 
+   // ===========================================================================
+   // Health Check
+   // ===========================================================================
+ 
+   async testConnection(): Promise&lt;{ connected: boolean; error?: string }&gt; {
+     if (!this.isConfigured()) {
+       return { connected: false, error: 'Moco API key or subdomain not configured' };
+     }
+ 
+     try {
+       // Try to list customers with limit 1 to test connection
+       await this.client.get('/customers', { params: { per_page: 1 } });
+       return { connected: true };
+     } catch (error) {
+       const message = error instanceof MocoError 
+         ? error.mocoMessage || error.message 
+         : (error as Error).message;
+       return { connected: false, error: message };
+     }
+   }
+ 
+   // ===========================================================================
+   // Customer Management
+   // ===========================================================================
+ 
+   /**
+    * Create a customer in Moco
+    */
+   async createCustomer(data: MocoCustomerData): Promise&lt;string&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const payload = {
+       name: data.name,
+       email: data.email,
+       vat_identifier: data.vat_id,
+       address: data.address,
+       country_code: data.country || 'DE',
+       website: data.website,
+       phone: data.phone,
+       info: data.info
+     };
+ 
+     // Remove undefined values
+     const cleanPayload = Object.fromEntries(
+       Object.entries(payload).filter(([_, v]) =&gt; v !== undefined)
+     );
+ 
+     console.log(&#96;[Moco] Creating customer: ${data.name}&#96;);
+     const response = await this.client.post&lt;MocoCustomer&gt;('/customers', cleanPayload);
+     console.log(&#96;[Moco] Customer created with ID: ${response.data.id}&#96;);
+     
+     return response.data.id;
+   }
+ 
+   /**
+    * Get customer by ID
+    */
+   async getCustomer(customerId: string): Promise&lt;MocoCustomer&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const response = await this.client.get&lt;MocoCustomer&gt;(&#96;/customers/${customerId}&#96;);
+     return response.data;
+   }
+ 
+   /**
+    * Search customers by email
+    */
+   async findCustomerByEmail(email: string): Promise&lt;MocoCustomer | null&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     try {
+       const response = await this.client.get&lt;MocoCustomer[]&gt;('/customers', {
+         params: { email }
+       });
+       
+       return response.data.length &gt; 0 ? response.data[0] : null;
+     } catch (error) {
+       if (error instanceof MocoError &amp;&amp; error.statusCode === 404) {
+         return null;
+       }
+       throw error;
+     }
+   }
+ 
+   /**
+    * Search customers by name
+    */
+   async findCustomerByName(name: string): Promise&lt;MocoCustomer | null&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     try {
+       const response = await this.client.get&lt;MocoCustomer[]&gt;('/customers', {
+         params: { name }
+       });
+       
+       return response.data.length &gt; 0 ? response.data[0] : null;
+     } catch (error) {
+       if (error instanceof MocoError &amp;&amp; error.statusCode === 404) {
+         return null;
+       }
+       throw error;
+     }
+   }
+ 
+   /**
+    * Update customer
+    */
+   async updateCustomer(customerId: string, data: Partial&lt;MocoCustomerData&gt;): Promise&lt;MocoCustomer&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const payload: Record&lt;string, unknown&gt; = {};
+     
+     if (data.name) payload.name = data.name;
+     if (data.email) payload.email = data.email;
+     if (data.vat_id) payload.vat_identifier = data.vat_id;
+     if (data.address) payload.address = data.address;
+     if (data.country) payload.country_code = data.country;
+     if (data.website) payload.website = data.website;
+     if (data.phone) payload.phone = data.phone;
+     if (data.info) payload.info = data.info;
+ 
+     console.log(&#96;[Moco] Updating customer: ${customerId}&#96;);
+     const response = await this.client.put&lt;MocoCustomer&gt;(&#96;/customers/${customerId}&#96;, payload);
+     return response.data;
+   }
+ 
+   // ===========================================================================
+   // Offer Management
+   // ===========================================================================
+ 
+   /**
+    * Create an offer/quote in Moco
+    */
+   async createOffer(data: MocoOfferData): Promise&lt;string&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const today = new Date().toISOString().split('T')[0];
+     
+     const items = data.items || [{
+       title: data.title,
+       quantity: 1,
+       unit_price: data.value,
+       net_total: data.value
+     }];
+ 
+     const payload = {
+       customer_id: data.customer_id,
+       title: data.title,
+       date: today,
+       info: data.info,
+       items: items.map(item =&gt; ({
+         title: item.title,
+         quantity: item.quantity,
+         unit_price: item.unit_price,
+         net_total: item.net_total || (item.quantity * item.unit_price)
+       }))
+     };
+ 
+     console.log(&#96;[Moco] Creating offer: ${data.title} for customer ${data.customer_id}&#96;);
+     const response = await this.client.post&lt;MocoOffer&gt;('/offers', payload);
+     console.log(&#96;[Moco] Offer created with ID: ${response.data.id}&#96;);
+     
+     return response.data.id;
+   }
+ 
+   /**
+    * Get offer by ID
+    */
+   async getOffer(offerId: string): Promise&lt;MocoOffer&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const response = await this.client.get&lt;MocoOffer&gt;(&#96;/offers/${offerId}&#96;);
+     return response.data;
+   }
+ 
+   /**
+    * List offers for a customer
+    */
+   async getOffersByCustomer(customerId: string): Promise&lt;MocoOffer[]&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const response = await this.client.get&lt;MocoOffer[]&gt;('/offers', {
+       params: { customer_id: customerId }
+     });
+     return response.data;
+   }
+ 
+   // ===========================================================================
+   // Invoice Management
+   // ===========================================================================
+ 
+   /**
+    * Create an invoice from an offer
+    */
+   async createInvoiceFromOffer(offerId: string): Promise&lt;string&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     console.log(&#96;[Moco] Creating invoice from offer: ${offerId}&#96;);
+     const response = await this.client.post&lt;MocoInvoice&gt;(&#96;/offers/${offerId}/create_invoice&#96;);
+     console.log(&#96;[Moco] Invoice created with ID: ${response.data.id}&#96;);
+     
+     return response.data.id;
+   }
+ 
+   /**
+    * Get invoice by ID
+    */
+   async getInvoice(invoiceId: string): Promise&lt;MocoInvoice&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const response = await this.client.get&lt;MocoInvoice&gt;(&#96;/invoices/${invoiceId}&#96;);
+     return response.data;
+   }
+ 
+   /**
+    * List invoices for a customer
+    */
+   async getInvoicesByCustomer(customerId: string): Promise&lt;MocoInvoice[]&gt; {
+     if (!this.isConfigured()) {
+       throw new MocoError('Moco not configured', 500);
+     }
+ 
+     const response = await this.client.get&lt;MocoInvoice[]&gt;('/invoices', {
+       params: { customer_id: customerId }
+     });
+     return response.data;
+   }
+ }
+ 
+ // =============================================================================
+ // Singleton Export
+ // =============================================================================
+ 
+ let mocoServiceInstance: MocoService | null = null;
+ 
+ export function getMocoService(): MocoService {
+   if (!mocoServiceInstance) {
+     mocoServiceInstance = new MocoService();
+   }
+   return mocoServiceInstance;
+ }
+ 
+ export default getMocoService;
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: E:\dname\crm_dna-me\src\workers\syncWorker.ts</summary>

**Chunk 1**
Lines added: 365, lines removed: 1

```diff
@@ -1,1 +1,365 @@
- 
+ // =============================================================================
+ // src/workers/syncWorker.ts
+ // Sync Worker for Moco and Slack integrations
+ // =============================================================================
+ 
+ import { Worker, Job } from 'bullmq';
+ import { redisOptions } from '../config/redis.js';
+ import { db } from '../db/index.js';
+ import { MocoService, MocoError } from '../integrations/moco.js';
+ import { config } from '../config/index.js';
+ import type { SyncJob, Lead, Deal } from '../types/index.js';
+ 
+ // =============================================================================
+ // Types
+ // =============================================================================
+ 
+ interface LeadWithOrganization extends Lead {
+   org_name?: string;
+   org_domain?: string;
+   vat_id?: string;
+ }
+ 
+ interface DealWithRelations extends Deal {
+   lead_email?: string;
+   customer_moco_id?: string;
+   lead_first_name?: string;
+   lead_last_name?: string;
+   org_name?: string;
+ }
+ 
+ interface SyncResult {
+   success: boolean;
+   action: string;
+   entity_id: string;
+   target: string;
+   result?: Record&lt;string, unknown&gt;;
+   error?: string;
+ }
+ 
+ // =============================================================================
+ // Moco Sync Processing
+ // =============================================================================
+ 
+ async function processMocoSync(
+   mocoService: MocoService,
+   entityType: string,
+   entityId: string,
+   action: string
+ ): Promise&lt;SyncResult&gt; {
+   switch (action) {
+     case 'create_customer':
+       return await createMocoCustomer(mocoService, entityId);
+     
+     case 'create_offer':
+       return await createMocoOffer(mocoService, entityId);
+     
+     case 'create_invoice':
+       return await createMocoInvoice(mocoService, entityId);
+     
+     default:
+       throw new Error(&#96;Unknown Moco action: ${action}&#96;);
+   }
+ }
+ 
+ // =============================================================================
+ // Create Moco Customer
+ // =============================================================================
+ 
+ async function createMocoCustomer(
+   mocoService: MocoService,
+   leadId: string
+ ): Promise&lt;SyncResult&gt; {
+   // Get lead with organization data
+   const lead = await db.queryOne&lt;LeadWithOrganization&gt;(&#96;
+     SELECT 
+       l.*,
+       o.name as org_name,
+       o.domain as org_domain,
+       o.vat_id,
+       o.moco_id as existing_moco_id
+     FROM leads l
+     LEFT JOIN organizations o ON l.organization_id = o.id
+     WHERE l.id = $1
+   &#96;, [leadId]);
+ 
+   if (!lead) {
+     return {
+       success: false,
+       action: 'create_customer',
+       entity_id: leadId,
+       target: 'moco',
+       error: 'Lead not found'
+     };
+   }
+ 
+   // Check if customer already exists in Moco
+   const existingCustomer = await mocoService.findCustomerByEmail(lead.email);
+   if (existingCustomer) {
+     // Update organization with existing Moco ID
+     if (lead.organization_id) {
+       await db.execute(&#96;
+         UPDATE organizations SET moco_id = $1, updated_at = NOW() WHERE id = $2
+       &#96;, [existingCustomer.id, lead.organization_id]);
+     }
+     
+     console.log(&#96;[SyncWorker] Customer already exists in Moco: ${existingCustomer.id}&#96;);
+     return {
+       success: true,
+       action: 'create_customer',
+       entity_id: leadId,
+       target: 'moco',
+       result: { moco_id: existingCustomer.id, existing: true }
+     };
+   }
+ 
+   // Determine customer name
+   const customerName = lead.org_name || 
+     &#96;${lead.first_name || ''} ${lead.last_name || ''}&#96;.trim() ||
+     lead.email.split('@')[0];
+ 
+   // Create customer in Moco
+   const mocoId = await mocoService.createCustomer({
+     name: customerName,
+     email: lead.email,
+     vat_id: lead.vat_id,
+     website: lead.org_domain ? &#96;https://${lead.org_domain}&#96; : undefined
+   });
+ 
+   // Update organization with Moco ID
+   if (lead.organization_id) {
+     await db.execute(&#96;
+       UPDATE organizations SET moco_id = $1, updated_at = NOW() WHERE id = $2
+     &#96;, [mocoId, lead.organization_id]);
+   }
+ 
+   console.log(&#96;[SyncWorker] Created Moco customer: ${mocoId} for lead ${leadId}&#96;);
+ 
+   return {
+     success: true,
+     action: 'create_customer',
+     entity_id: leadId,
+     target: 'moco',
+     result: { moco_id: mocoId }
+   };
+ }
+ 
+ // =============================================================================
+ // Create Moco Offer
+ // =============================================================================
+ 
+ async function createMocoOffer(
+   mocoService: MocoService,
+   dealId: string
+ ): Promise&lt;SyncResult&gt; {
+   // Get deal with related data
+   const deal = await db.queryOne&lt;DealWithRelations&gt;(&#96;
+     SELECT 
+       d.*,
+       l.email as lead_email,
+       l.first_name as lead_first_name,
+       l.last_name as lead_last_name,
+       o.moco_id as customer_moco_id,
+       o.name as org_name
+     FROM deals d
+     JOIN leads l ON d.lead_id = l.id
+     LEFT JOIN organizations o ON l.organization_id = o.id
+     WHERE d.id = $1
+   &#96;, [dealId]);
+ 
+   if (!deal) {
+     return {
+       success: false,
+       action: 'create_offer',
+       entity_id: dealId,
+       target: 'moco',
+       error: 'Deal not found'
+     };
+   }
+ 
+   // Check if we have a Moco customer ID
+   if (!deal.customer_moco_id) {
+     // Try to find customer by email
+     const customer = await mocoService.findCustomerByEmail(deal.lead_email || '');
+     if (customer) {
+       deal.customer_moco_id = customer.id;
+     } else {
+       return {
+         success: false,
+         action: 'create_offer',
+         entity_id: dealId,
+         target: 'moco',
+         error: 'No Moco customer found. Create customer first.'
+       };
+     }
+   }
+ 
+   // Check if offer already exists
+   if (deal.moco_offer_id) {
+     console.log(&#96;[SyncWorker] Offer already exists: ${deal.moco_offer_id}&#96;);
+     return {
+       success: true,
+       action: 'create_offer',
+       entity_id: dealId,
+       target: 'moco',
+       result: { moco_offer_id: deal.moco_offer_id, existing: true }
+     };
+   }
+ 
+   // Create offer title
+   const offerTitle = deal.name || 
+     &#96;${deal.org_name || deal.lead_first_name || ''} - Deal&#96;;
+ 
+   // Create offer in Moco
+   const offerId = await mocoService.createOffer({
+     customer_id: deal.customer_moco_id,
+     title: offerTitle,
+     value: deal.value || 0
+   });
+ 
+   // Update deal with Moco offer ID
+   await db.execute(&#96;
+     UPDATE deals SET moco_offer_id = $1, updated_at = NOW() WHERE id = $2
+   &#96;, [offerId, dealId]);
+ 
+   console.log(&#96;[SyncWorker] Created Moco offer: ${offerId} for deal ${dealId}&#96;);
+ 
+   return {
+     success: true,
+     action: 'create_offer',
+     entity_id: dealId,
+     target: 'moco',
+     result: { moco_offer_id: offerId }
+   };
+ }
+ 
+ // =============================================================================
+ // Create Moco Invoice
+ // =============================================================================
+ 
+ async function createMocoInvoice(
+   mocoService: MocoService,
+   offerId: string
+ ): Promise&lt;SyncResult&gt; {
+   // Check if this is a deal ID or offer ID
+   const deal = await db.queryOne&lt;Deal&gt;(&#96;
+     SELECT * FROM deals WHERE id = $1 OR moco_offer_id = $1
+   &#96;, [offerId]);
+ 
+   let mocoOfferId = offerId;
+   
+   if (deal &amp;&amp; deal.moco_offer_id) {
+     mocoOfferId = deal.moco_offer_id;
+   }
+ 
+   // Create invoice from offer
+   const invoiceId = await mocoService.createInvoiceFromOffer(mocoOfferId);
+ 
+   console.log(&#96;[SyncWorker] Created Moco invoice: ${invoiceId} from offer ${mocoOfferId}&#96;);
+ 
+   return {
+     success: true,
+     action: 'create_invoice',
+     entity_id: offerId,
+     target: 'moco',
+     result: { moco_invoice_id: invoiceId }
+   };
+ }
+ 
+ // =============================================================================
+ // Slack Sync Processing (Placeholder for future implementation)
+ // =============================================================================
+ 
+ async function processSlackSync(data: SyncJob): Promise&lt;SyncResult&gt; {
+   // Placeholder for Slack integration (to be implemented in Etappe 12)
+   console.log(&#96;[SyncWorker] Slack sync not yet implemented: ${data.action}&#96;);
+   
+   return {
+     success: true,
+     action: data.action,
+     entity_id: data.entity_id,
+     target: 'slack',
+     result: { message: 'Slack sync will be implemented in Etappe 12' }
+   };
+ }
+ 
+ // =============================================================================
+ // Create Sync Worker
+ // =============================================================================
+ 
+ export function createSyncWorker(mocoService: MocoService): Worker&lt;SyncJob&gt; {
+   const worker = new Worker&lt;SyncJob&gt;(
+     'sync',
+     async (job: Job&lt;SyncJob&gt;) =&gt; {
+       const { entity_type, entity_id, target, action } = job.data;
+       
+       console.log(&#96;[SyncWorker] Processing: ${action} ${entity_type} ${entity_id} to ${target}&#96;);
+       
+       try {
+         let result: SyncResult;
+         
+         switch (target) {
+           case 'moco':
+             // Check if Moco is enabled
+             if (!config.features.mocoSync) {
+               console.log('[SyncWorker] Moco sync is disabled');
+               return {
+                 success: true,
+                 skipped: true,
+                 reason: 'Moco sync disabled'
+               };
+             }
+             
+             result = await processMocoSync(mocoService, entity_type, entity_id, action);
+             break;
+             
+           case 'slack':
+             result = await processSlackSync(job.data);
+             break;
+             
+           default:
+             throw new Error(&#96;Unknown sync target: ${target}&#96;);
+         }
+         
+         console.log(&#96;[SyncWorker] Completed: ${action} ${entity_type} ${entity_id} - Success: ${result.success}&#96;);
+         return result;
+         
+       } catch (error) {
+         const errorMessage = error instanceof MocoError 
+           ? &#96;${error.message} (${error.statusCode}): ${error.mocoMessage}&#96;
+           : (error as Error).message;
+         
+         console.error(&#96;[SyncWorker] Error processing ${action}:&#96;, errorMessage);
+         
+         // Re-throw to trigger BullMQ retry
+         throw error;
+       }
+     },
+     {
+       connection: redisOptions,
+       concurrency: 3,
+       limiter: {
+         max: 10,
+         duration: 1000 // Max 10 jobs per second
+       }
+     }
+   );
+   
+   // Event handlers
+   worker.on('completed', (job) =&gt; {
+     console.log(&#96;[SyncWorker] Job ${job.id} completed successfully&#96;);
+   });
+   
+   worker.on('failed', (job, error) =&gt; {
+     console.error(&#96;[SyncWorker] Job ${job?.id} failed:&#96;, error.message);
+   });
+   
+   worker.on('error', (error) =&gt; {
+     console.error('[SyncWorker] Worker error:', error);
+   });
+   
+   return worker;
+ }
+ 
+ export default createSyncWorker;
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 280, lines removed: 1

```diff
@@ -1,1 +1,280 @@
- 
+ // =============================================================================
+ // src/api/routes/integrations.ts
+ // Integrations API Routes (Moco, Slack)
+ // =============================================================================
+ 
+ import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
+ import { z } from 'zod';
+ import { getMocoService } from '../../integrations/moco.js';
+ import { getSyncQueue } from '../../config/queues.js';
+ import { db } from '../../db/index.js';
+ import { NotFoundError, ValidationError, BusinessLogicError } from '../../errors/index.js';
+ import { config } from '../../config/index.js';
+ import type { SyncJob, Lead, Deal } from '../../types/index.js';
+ 
+ // =============================================================================
+ // Schemas
+ // =============================================================================
+ 
+ const manualMocoSyncSchema = z.object({
+   action: z.enum(['create_customer', 'create_offer', 'create_invoice']),
+   force: z.boolean().optional().default(false)
+ });
+ 
+ const mocoWebhookSchema = z.object({
+   event: z.string(),
+   entity_type: z.string(),
+   entity_id: z.string(),
+   data: z.record(z.unknown()).optional()
+ });
+ 
+ // =============================================================================
+ // Routes Plugin
+ // =============================================================================
+ 
+ export async function integrationsRoutes(fastify: FastifyInstance): Promise&lt;void&gt; {
+   const mocoService = getMocoService();
+   const syncQueue = getSyncQueue();
+ 
+   // ===========================================================================
+   // GET /integrations/moco/status - Check Moco connection status
+   // ===========================================================================
+ 
+   fastify.get('/integrations/moco/status', async (request: FastifyRequest, reply: FastifyReply) =&gt; {
+     const isConfigured = mocoService.isConfigured();
+     
+     if (!isConfigured) {
+       return {
+         status: 'not_configured',
+         message: 'Moco API key or subdomain not configured',
+         enabled: config.features.mocoSync
+       };
+     }
+ 
+     const connectionTest = await mocoService.testConnection();
+     
+     return {
+       status: connectionTest.connected ? 'connected' : 'disconnected',
+       message: connectionTest.error || 'Connection successful',
+       enabled: config.features.mocoSync,
+       subdomain: config.moco.subdomain
+     };
+   });
+ 
+   // ===========================================================================
+   // POST /integrations/moco/sync/:leadId - Manually trigger Moco sync for lead
+   // ===========================================================================
+ 
+   fastify.post('/integrations/moco/sync/lead/:leadId', async (
+     request: FastifyRequest&lt;{ 
+       Params: { leadId: string };
+       Body: z.infer&lt;typeof manualMocoSyncSchema&gt;;
+     }&gt;, 
+     reply: FastifyReply
+   ) =&gt; {
+     const { leadId } = request.params;
+     const body = manualMocoSyncSchema.parse(request.body || { action: 'create_customer' });
+     
+     // Check if Moco is configured
+     if (!mocoService.isConfigured()) {
+       throw new BusinessLogicError('Moco is not configured');
+     }
+ 
+     // Verify lead exists
+     const lead = await db.queryOne&lt;Lead&gt;(
+       'SELECT * FROM leads WHERE id = $1',
+       [leadId]
+     );
+ 
+     if (!lead) {
+       throw new NotFoundError('Lead', leadId);
+     }
+ 
+     // Validate action for lead
+     if (body.action !== 'create_customer') {
+       throw new ValidationError('Only create_customer action is valid for leads');
+     }
+ 
+     // Queue sync job
+     const job: SyncJob = {
+       entity_type: 'lead',
+       entity_id: leadId,
+       target: 'moco',
+       action: body.action
+     };
+ 
+     await syncQueue.add(&#96;moco-manual-${body.action}&#96;, job, {
+       priority: 1 // High priority for manual syncs
+     });
+ 
+     return {
+       message: &#96;Moco sync job queued: ${body.action}&#96;,
+       lead_id: leadId,
+       job_type: body.action
+     };
+   });
+ 
+   // ===========================================================================
+   // POST /integrations/moco/sync/deal/:dealId - Manually trigger Moco sync for deal
+   // ===========================================================================
+ 
+   fastify.post('/integrations/moco/sync/deal/:dealId', async (
+     request: FastifyRequest&lt;{ 
+       Params: { dealId: string };
+       Body: z.infer&lt;typeof manualMocoSyncSchema&gt;;
+     }&gt;, 
+     reply: FastifyReply
+   ) =&gt; {
+     const { dealId } = request.params;
+     const body = manualMocoSyncSchema.parse(request.body || { action: 'create_offer' });
+     
+     // Check if Moco is configured
+     if (!mocoService.isConfigured()) {
+       throw new BusinessLogicError('Moco is not configured');
+     }
+ 
+     // Verify deal exists
+     const deal = await db.queryOne&lt;Deal&gt;(
+       'SELECT * FROM deals WHERE id = $1',
+       [dealId]
+     );
+ 
+     if (!deal) {
+       throw new NotFoundError('Deal', dealId);
+     }
+ 
+     // Validate action for deal
+     if (!['create_offer', 'create_invoice'].includes(body.action)) {
+       throw new ValidationError('Only create_offer or create_invoice actions are valid for deals');
+     }
+ 
+     // Queue sync job
+     const job: SyncJob = {
+       entity_type: 'deal',
+       entity_id: dealId,
+       target: 'moco',
+       action: body.action
+     };
+ 
+     await syncQueue.add(&#96;moco-manual-${body.action}&#96;, job, {
+       priority: 1
+     });
+ 
+     return {
+       message: &#96;Moco sync job queued: ${body.action}&#96;,
+       deal_id: dealId,
+       job_type: body.action
+     };
+   });
+ 
+   // ===========================================================================
+   // POST /integrations/moco/webhook - Receive Moco webhooks (payment status, etc.)
+   // ===========================================================================
+ 
+   fastify.post('/integrations/moco/webhook', async (
+     request: FastifyRequest&lt;{ Body: z.infer&lt;typeof mocoWebhookSchema&gt; }&gt;,
+     reply: FastifyReply
+   ) =&gt; {
+     try {
+       const body = mocoWebhookSchema.parse(request.body);
+       
+       request.log.info({
+         event: body.event,
+         entity_type: body.entity_type,
+         entity_id: body.entity_id
+       }, 'Received Moco webhook');
+ 
+       // Handle different webhook events
+       switch (body.event) {
+         case 'invoice.paid':
+           await handleInvoicePaid(body.entity_id, body.data);
+           break;
+         
+         case 'invoice.cancelled':
+           await handleInvoiceCancelled(body.entity_id, body.data);
+           break;
+         
+         default:
+           request.log.info(&#96;Unhandled Moco webhook event: ${body.event}&#96;);
+       }
+ 
+       return { received: true, event: body.event };
+     } catch (error) {
+       request.log.error(error, 'Error processing Moco webhook');
+       throw error;
+     }
+   });
+ 
+   // ===========================================================================
+   // GET /integrations/moco/customer/:email - Find Moco customer by email
+   // ===========================================================================
+ 
+   fastify.get('/integrations/moco/customer/:email', async (
+     request: FastifyRequest&lt;{ Params: { email: string } }&gt;,
+     reply: FastifyReply
+   ) =&gt; {
+     const { email } = request.params;
+ 
+     if (!mocoService.isConfigured()) {
+       throw new BusinessLogicError('Moco is not configured');
+     }
+ 
+     const customer = await mocoService.findCustomerByEmail(email);
+ 
+     if (!customer) {
+       throw new NotFoundError('Moco Customer', email);
+     }
+ 
+     return customer;
+   });
+ 
+   // ===========================================================================
+   // GET /integrations/status - Get status of all integrations
+   // ===========================================================================
+ 
+   fastify.get('/integrations/status', async (request: FastifyRequest, reply: FastifyReply) =&gt; {
+     const mocoConfigured = mocoService.isConfigured();
+     let mocoConnected = false;
+ 
+     if (mocoConfigured) {
+       const connectionTest = await mocoService.testConnection();
+       mocoConnected = connectionTest.connected;
+     }
+ 
+     return {
+       moco: {
+         configured: mocoConfigured,
+         connected: mocoConnected,
+         enabled: config.features.mocoSync
+       },
+       slack: {
+         configured: !!config.slack.webhookUrl,
+         connected: false, // Will be implemented in Etappe 12
+         enabled: config.features.slackAlerts
+       }
+     };
+   });
+ }
+ 
+ // =============================================================================
+ // Webhook Handlers
+ // =============================================================================
+ 
+ async function handleInvoicePaid(invoiceId: string, data?: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {
+   console.log(&#96;[Moco Webhook] Invoice paid: ${invoiceId}&#96;);
+   
+   // Find deal by moco_offer_id (if we stored it)
+   // Note: We might need to track invoice IDs separately
+   // For now, just log the event
+   
+   // Future: Update deal status, notify team, etc.
+ }
+ 
+ async function handleInvoiceCancelled(invoiceId: string, data?: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {
+   console.log(&#96;[Moco Webhook] Invoice cancelled: ${invoiceId}&#96;);
+   
+   // Future: Handle invoice cancellation
+ }
+ 
+ export default integrationsRoutes;
+ 
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich noch:
1. Workers index.ts aktualisieren, um den Sync Worker zu integrieren
2. src/index.ts aktualisieren, um die integrations Routen zu registrieren
3. Linter-Fehler überprüfen</details></think>

---

Jetzt aktualisiere ich die Workers und den Main Entry Point:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\workers\index.ts</summary>

**Chunk 1**
Lines added: 2, lines removed: undefined

```diff
@@ -10,7 +10,9 @@
  import { createEventWorker } from './eventWorker.js';
  import { createRoutingWorker } from './routingWorker.js';
+ import { createSyncWorker } from './syncWorker.js';
  import { getScoringEngine } from '../services/scoringEngine.js';
  import { getIntentDetector } from '../services/intentDetector.js';
  import { getPipelineRouter } from '../services/pipelineRouter.js';
+ import { getMocoService } from '../integrations/moco.js';
  
  console.log(&#96;
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\workers\index.ts</summary>

**Chunk 1**
Lines added: 13, lines removed: 1

```diff
@@ -66,8 +66,20 @@
    workers.push(routingWorker);
    console.log('✅ Routing Worker started (concurrency: 5)');
+ 
+   // Initialize Moco Service
+   const mocoService = getMocoService();
+   if (mocoService.isConfigured()) {
+     console.log('✅ Moco Service initialized');
+   } else {
+     console.log('⚠️ Moco Service not configured (missing API key or subdomain)');
+   }
+ 
+   // Sync Worker - handles Moco and Slack synchronization
+   const syncWorker = createSyncWorker(mocoService);
+   workers.push(syncWorker);
+   console.log('✅ Sync Worker started (concurrency: 3, rate limit: 10/sec)');
  
    // Future workers will be added in later phases:
    // - Decay Worker (Phase 12)
-   // - Sync Worker (Phase 10)
    // - Automation Worker (Phase 11)
  
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich noch die integrations Routen in src/index.ts registrieren.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\index.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -17,4 +17,5 @@
  import { pipelinesRoutes } from './api/routes/pipelines.js';
  import { dealsRoutes } from './api/routes/deals.js';
+ import { integrationsRoutes } from './api/routes/integrations.js';
  import type { HealthCheckResponse } from './types/index.js';
  
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\index.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -135,4 +135,5 @@
  await fastify.register(pipelinesRoutes, { prefix: '/api/v1' });
  await fastify.register(dealsRoutes, { prefix: '/api/v1' });
+ await fastify.register(integrationsRoutes, { prefix: '/api/v1' });
  
  // =============================================================================
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Jetzt muss ich noch die Linter-Fehler überprüfen und gegebenenfalls beheben.</details></think>

---

Jetzt überprüfe ich die Linter-Fehler:

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 5 files</summary>
      
Lint paths:

- `E:\dname\crm_dna-me\src\integrations\moco.ts`
- `E:\dname\crm_dna-me\src\workers\syncWorker.ts`
- `E:\dname\crm_dna-me\src\api\routes\integrations.ts`
- `E:\dname\crm_dna-me\src\workers\index.ts`
- `E:\dname\crm_dna-me\src\index.ts`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Ausgezeichnet! Keine Linter-Fehler. Jetzt sollte ich den Code kompilieren und testen. Lass mich zuerst die Terminals überprüfen, um zu sehen, ob es bereits laufende Server gibt.</details></think>

---

Keine Linter-Fehler. Lass mich die Terminal-Status überprüfen und dann den Code kompilieren:

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Die Workers laufen in Terminal 4, und der API-Server scheint auch zu laufen (Health-Check wurde vor einiger Zeit durchgeführt). Ich werde jetzt einen Build durchführen, um sicherzustellen, dass alles kompiliert, und dann testen.</details></think>

---

Ich sehe, dass die Workers bereits laufen. Lass mich den Code kompilieren, um sicherzustellen, dass alles funktioniert:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd E:\dname\crm_dna-me && npm run build</summary>

```bash
cd E:\dname\crm_dna-me && npm run build
```

```
In C:\Users\����ᠭ��\AppData\Local\Temp\ps-script-f7e66e00-0c49-4647-9cd9-e875be101c94.ps1:7 Zeichen:24
+ cd E:\dname\crm_dna-me &amp;&amp; npm run build
+                        ~~
Das Token "&amp;&amp;" ist in dieser Version kein gultiges Anweisungstrennzeichen.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : InvalidEndOfLine
 

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
PowerShell verwendet nicht && als Anweisungstrennzeichen. Ich muss stattdessen ; verwenden oder die Befehle in separate Anrufe aufteilen.</details></think>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd E:\dname\crm_dna-me; npm run build</summary>

```bash
cd E:\dname\crm_dna-me; npm run build
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Es gab einen Build-Fehler. Lass mich die Ausgabe lesen, um das Problem zu verstehen.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: c:\Users\Александр\.cursor\projects\e-dname-crm-dna-me\agent-tools\ff828cd7-5a2e-4d61-bafe-0b6418e65df4.txt</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Ich sehe viele TypeScript-Build-Fehler, aber die meisten sind vorbestehende Fehler (unbenutzte Variablen, etc.) und nicht von meinen neuen Dateien verursacht. Die wichtigen TypeScript-Fehler in meiner integrations.ts-Datei sind:

1. Zeile 43, 73, 126, 176, 214, 235: `reply` ist deklariert aber nie verwendet
2. Zeile 263, 273: `data` Parameter ist nicht verwendet

Ich muss diese Fehler in meiner integrations.ts beheben. Die Fehler sind:
- Unbenutzte reply Parameter in Routenhandlern - ich kann sie mit Unterstrich-Präfix versehen
- entityType in syncWorker wird nicht verwendet (Zeile 46)

Lass mich diese Fehler korrigieren.</details></think>

---

Ich sehe TypeScript-Fehler. Die meisten sind vorbestehende Fehler, aber einige sind in meinen neuen Dateien. Lass mich diese beheben:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -41,5 +41,5 @@
    // ===========================================================================
  
-   fastify.get('/integrations/moco/status', async (request: FastifyRequest, reply: FastifyReply) =&gt; {
+   fastify.get('/integrations/moco/status', async (_request: FastifyRequest, _reply: FastifyReply) =&gt; {
      const isConfigured = mocoService.isConfigured();
      
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -71,5 +71,5 @@
        Body: z.infer&lt;typeof manualMocoSyncSchema&gt;;
      }&gt;, 
-     reply: FastifyReply
+     _reply: FastifyReply
    ) =&gt; {
      const { leadId } = request.params;
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -124,5 +124,5 @@
        Body: z.infer&lt;typeof manualMocoSyncSchema&gt;;
      }&gt;, 
-     reply: FastifyReply
+     _reply: FastifyReply
    ) =&gt; {
      const { dealId } = request.params;
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -174,5 +174,5 @@
    fastify.post('/integrations/moco/webhook', async (
      request: FastifyRequest&lt;{ Body: z.infer&lt;typeof mocoWebhookSchema&gt; }&gt;,
-     reply: FastifyReply
+     _reply: FastifyReply
    ) =&gt; {
      try {
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -212,5 +212,5 @@
    fastify.get('/integrations/moco/customer/:email', async (
      request: FastifyRequest&lt;{ Params: { email: string } }&gt;,
-     reply: FastifyReply
+     _reply: FastifyReply
    ) =&gt; {
      const { email } = request.params;
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -233,5 +233,5 @@
    // ===========================================================================
  
-   fastify.get('/integrations/status', async (request: FastifyRequest, reply: FastifyReply) =&gt; {
+   fastify.get('/integrations/status', async (_request: FastifyRequest, _reply: FastifyReply) =&gt; {
      const mocoConfigured = mocoService.isConfigured();
      let mocoConnected = false;
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -261,5 +261,5 @@
  // =============================================================================
  
- async function handleInvoicePaid(invoiceId: string, data?: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {
+ async function handleInvoicePaid(invoiceId: string, _data?: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {
    console.log(&#96;[Moco Webhook] Invoice paid: ${invoiceId}&#96;);
    
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\api\routes\integrations.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -271,5 +271,5 @@
  }
  
- async function handleInvoiceCancelled(invoiceId: string, data?: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {
+ async function handleInvoiceCancelled(invoiceId: string, _data?: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {
    console.log(&#96;[Moco Webhook] Invoice cancelled: ${invoiceId}&#96;);
    
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: E:\dname\crm_dna-me\src\workers\syncWorker.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -44,5 +44,5 @@
  async function processMocoSync(
    mocoService: MocoService,
-   entityType: string,
+   _entityType: string,
    entityId: string,
    action: string
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Ich habe alle Fehler in meinen Dateien behoben. Die restlichen TypeScript-Fehler sind in den bestehenden Dateien, die nicht Teil meiner Implementierung sind. Lass mich überprüfen, ob es jetzt Linter-Fehler in meinen Dateien gibt, und dann den Server starten, um zu testen.</details></think>

---

Jetzt überprüfe ich die Linter-Fehler erneut:

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 4 files</summary>
      
Lint paths:

- `E:\dname\crm_dna-me\src\integrations\moco.ts`
- `E:\dname\crm_dna-me\src\workers\syncWorker.ts`
- `E:\dname\crm_dna-me\src\api\routes\integrations.ts`
- `E:\dname\crm_dna-me\src\workers\index.ts`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Sehr gut, keine Linter-Fehler mehr. Lass mich jetzt den Dev-Server testen, um sicherzustellen, dass alles funktioniert. Da die meisten vorbestehenden Fehler nur "unused variable" Warnungen sind (die bei der Ausführung mit tsx nicht relevant sind), sollte ich den Dev-Server direkt starten können.</details></think>

---

Ausgezeichnet! Keine Linter-Fehler in meinen neuen Dateien. Lass mich jetzt den Dev-Server starten, um die Integration zu testen:

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd E:\dname\crm_dna-me; npm run dev</summary>

```bash
cd E:\dname\crm_dna-me; npm run dev
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Lass mich warten und die Ausgabe überprüfen, um zu sehen, ob der Server erfolgreich gestartet wurde.</details></think>

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_cursor-browser-extension_browser_wait_for">
<details>
          <summary>Tool use: **mcp_cursor-browser-extension_browser_wait_for**</summary>
      
*Called tool*: cursor-browser-extension - browser_wait_for: Wait for text to appear or disappear or a specified time to pass

*Parameters*:
  * time: 3

*Result*:
Waited for 3

Code:
```javascript
await new Promise(f => setTimeout(f, 3 * 1000));
```


### Page state
- Page URL: about:blank
- Page Title: 
- Page Snapshot:
```yaml

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Lass mich die Terminal-Ausgabe überprüfen, um zu sehen, ob der Server läuft.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: c:\Users\Александр\.cursor\projects\e-dname-crm-dna-me\terminals\5.txt</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Der Server-Start ist fehlgeschlagen. Lass mich die vollständige Fehlermeldung lesen.</details></think>

---

Es scheint ein Fehler aufgetreten zu sein. Lass mich mehr Details sehen:

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_cursor-browser-extension_browser_wait_for">
<details>
          <summary>Tool use: **mcp_cursor-browser-extension_browser_wait_for**</summary>
      
*Called tool*: cursor-browser-extension - browser_wait_for: Wait for text to appear or disappear or a specified time to pass

*Parameters*:
  * time: 3

*Result*:
Waited for 3

Code:
```javascript
await new Promise(f => setTimeout(f, 3 * 1000));
```


### Page state
- Page URL: about:blank
- Page Title: 
- Page Snapshot:
```yaml

```
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: c:\Users\Александр\.cursor\projects\e-dname-crm-dna-me\terminals\5.txt</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Die Ausgabe scheint unvollständig zu sein. Vielleicht läuft der Server noch und ich muss prüfen, ob er auf eine bestimmte Port lauscht. Lass mich den Endpunkt direkt aufrufen, um zu sehen, ob er funktioniert.</details></think>

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_cursor-browser-extension_browser_wait_for">
<details>
          <summary>Tool use: **mcp_cursor-browser-extension_browser_wait_for**</summary>
      
*Called tool*: cursor-browser-extension - browser_wait_for: Wait for text to appear or disappear or a specified time to pass

*Parameters*:
  * time: 5

*Result*:
Waited for 5

Code:
```javascript
await new Promise(f => setTimeout(f, 5 * 1000));
```


### Page state
- Page URL: about:blank
- Page Title: 
- Page Snapshot:
```yaml

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Lass mich die Terminal-Ausgabe nochmals überprüfen - vielleicht wurde der Fehler bereits angezeigt.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: c:\Users\Александр\.cursor\projects\e-dname-crm-dna-me\terminals\5.txt</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Der Server scheint fehlgeschlagen zu sein, aber die Fehlermeldung ist abgeschnitten. Lass mich prüfen, ob der Port vielleicht schon belegt ist. Oder vielleicht brauchen wir eine kurze Pause. Lass mich versuchen, den Health-Endpunkt im Browser zu erreichen.</details></think>

---

Lass mich den Health-Endpunkt testen:

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_cursor-browser-extension_browser_navigate">
<details>
          <summary>Tool use: **mcp_cursor-browser-extension_browser_navigate**</summary>
      
*Called tool*: cursor-browser-extension - browser_navigate: Navigate to a URL

*Parameters*:
  * url: http://localhost:3000/health

*Result*:


### Page state
- Page URL: http://localhost:3000/health
- Page Title: 
- Page Snapshot:
```yaml
- generic [ref=e2]: "{\"status\":\"healthy\",\"timestamp\":\"2026-01-21T16:39:03.248Z\",\"version\":\"1.0.0\",\"services\":{\"database\":true,\"redis\":true}}"
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Der Server läuft! Die Fehlermeldung im Log war irreführend. Lass mich jetzt die Integrations-Endpunkte testen.</details></think>

---

Ausgezeichnet! Der Server läuft! Jetzt teste ich die neuen Moco-Integrations-Endpunkte:

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_cursor-browser-extension_browser_navigate">
<details>
          <summary>Tool use: **mcp_cursor-browser-extension_browser_navigate**</summary>
      
*Called tool*: cursor-browser-extension - browser_navigate: Navigate to a URL

*Parameters*:
  * url: http://localhost:3000/api/v1/integrations/moco/status

*Result*:


### Page state
- Page URL: http://localhost:3000/api/v1/integrations/moco/status
- Page Title: 
- Page Snapshot:
```yaml
- generic [ref=e2]: "{\"status\":\"disconnected\",\"message\":\"Subdomain does not exist.\",\"enabled\":false,\"subdomain\":\"your_company\"}"
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Perfekt! Der Moco-Status-Endpunkt funktioniert. Er zeigt korrekt an, dass Moco "disconnected" ist (weil wir keinen echten API-Key haben) und dass die Subdomain auf den Standardwert "your_company" gesetzt ist.

Lass mich jetzt den allgemeinen Integrations-Status-Endpunkt testen.</details></think>

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_cursor-browser-extension_browser_navigate">
<details>
          <summary>Tool use: **mcp_cursor-browser-extension_browser_navigate**</summary>
      
*Called tool*: cursor-browser-extension - browser_navigate: Navigate to a URL

*Parameters*:
  * url: http://localhost:3000/api/v1/integrations/status

*Result*:


### Page state
- Page URL: http://localhost:3000/api/v1/integrations/status
- Page Title: 
- Page Snapshot:
```yaml
- generic [ref=e2]: "{\"moco\":{\"configured\":true,\"connected\":false,\"enabled\":false},\"slack\":{\"configured\":true,\"connected\":false,\"enabled\":false}}"
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Alle Integrations-Endpunkte funktionieren! Lass mich jetzt auch die Workers überprüfen, ob sie den Sync Worker richtig initialisiert haben. Ich sollte auch das Terminal 4 überprüfen, wo die Workers laufen sollten.</details></think>

---

Alle Moco-Integrations-Endpunkte funktionieren! Lass mich jetzt die Workers überprüfen:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: c:\Users\Александр\.cursor\projects\e-dname-crm-dna-me\terminals\4.txt</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Die Workers laufen, aber der Sync Worker wurde noch nicht gestartet - das liegt daran, dass die Workers vor meinen Änderungen gestartet wurden. Ich muss die Workers neu starten, um den Sync Worker zu aktivieren. Aber bevor ich das tue, lass mich die TODO-Liste aktualisieren.</details></think>

---

Die Workers laufen noch mit der alten Konfiguration. Ich muss sie neu starten, um den neuen Sync Worker zu aktivieren. Aber zuerst lassen Sie mich den aktuellen Stand zusammenfassen und die Etappe 10 als abgeschlossen markieren:

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Etappe 10: Moco Integration - Moco Service, Sync Worker

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Etappe 10 ist jetzt abgeschlossen! Lass mich eine Zusammenfassung erstellen.</details></think>

---

**Etappe 10: Moco Integration ist vollständig implementiert!** ✅

Ich habe folgende Komponenten erstellt:

### 1. `src/integrations/moco.ts` - MocoService
- Vollständige Moco API-Integration mit axios
- Kunden-Management (erstellen, suchen, aktualisieren)
- Angebots-Management (erstellen, abrufen)
- Rechnungs-Management (aus Angebot erstellen)
- Health-Check und Verbindungstest
- Error-Handling mit MocoError-Klasse

### 2. `src/workers/syncWorker.ts` - Sync Worker
- Verarbeitet Moco-Sync-Jobs aus der Queue
- `create_customer` - Erstellt Kunden in Moco
- `create_offer` - Erstellt Angebote für Deals
- `create_invoice` - Erstellt Rechnungen aus Angeboten
- Rate Limiting (10 Jobs/Sekunde)
- Automatische Retry-Logik bei Fehlern

### 3. `src/api/routes/integrations.ts` - API Endpunkte
- `GET /api/v1/integrations/moco/status` - Moco-Verbindungsstatus
- `POST /api/v1/integrations/moco/sync/lead/:leadId` - Manueller Lead-Sync
- `POST /api/v1/integrations/moco/sync/deal/:dealId` - Manueller Deal-Sync
- `POST /api/v1/integrations/moco/webhook` - Moco-Webhooks empfangen
- `GET /api/v1/integrations/moco/customer/:email` - Kunden suchen
- `GET /api/v1/integrations/status` - Alle Integrations-Status

### 4. Aktualisierungen
- `src/workers/index.ts` - Sync Worker hinzugefügt
- `src/index.ts` - Integrations-Routen registriert

### Getestet und verifiziert:
- ✅ API-Server läuft erfolgreich
- ✅ `/api/v1/integrations/moco/status` gibt korrekten Status zurück
- ✅ `/api/v1/integrations/status` zeigt alle Integrations

**Hinweis:** Um den Sync Worker zu aktivieren, müssen die Workers neu gestartet werden. Der `dealService` ist bereits so konfiguriert, dass er bei gewonnenen Deals automatisch Moco-Sync-Jobs in die Queue legt.

---

