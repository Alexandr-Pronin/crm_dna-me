# üöÄ DNA ME CRM - –ü–æ–ª–Ω—ã–π –ü–æ—à–∞–≥–æ–≤—ã–π –ì–∞–π–¥ –¥–ª—è Cursor

**–¶–µ–ª—å:** –°–æ–∑–¥–∞—Ç—å –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—É—é CRM –ø–ª–∞—Ç—Ñ–æ—Ä–º—É —Å –Ω—É–ª—è –∑–∞ 2-3 –¥–Ω—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã  
**–£—Ä–æ–≤–µ–Ω—å:** –°—Ä–µ–¥–Ω–∏–π (–Ω—É–∂–Ω–æ –ø–æ–Ω–∏–º–∞–Ω–∏–µ Node.js, SQL, API)  
**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –†–∞–±–æ—Ç–∞—é—â–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å Event Ingestion, Scoring, Intent Detection, Smart Routing

---

# üìã –°–û–î–ï–†–ñ–ê–ù–ò–ï

- [–≠—Ç–∞–ø 0: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è](#—ç—Ç–∞–ø-0-–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞-–æ–∫—Ä—É–∂–µ–Ω–∏—è-30-–º–∏–Ω—É—Ç)
- [–≠—Ç–∞–ø 1: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–µ–∫—Ç–∞](#—ç—Ç–∞–ø-1-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è-–ø—Ä–æ–µ–∫—Ç–∞-1-—á–∞—Å)
- [–≠—Ç–∞–ø 2: –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö](#—ç—Ç–∞–ø-2-–±–∞–∑–∞-–¥–∞–Ω–Ω—ã—Ö-1-—á–∞—Å)
- [–≠—Ç–∞–ø 3: –ë–∞–∑–æ–≤—ã–π API —Å–µ—Ä–≤–µ—Ä](#—ç—Ç–∞–ø-3-–±–∞–∑–æ–≤—ã–π-api-—Å–µ—Ä–≤–µ—Ä-1-—á–∞—Å)
- [–≠—Ç–∞–ø 4: Event Ingestion](#—ç—Ç–∞–ø-4-event-ingestion-2-—á–∞—Å–∞)
- [–≠—Ç–∞–ø 5: Lead Management](#—ç—Ç–∞–ø-5-lead-management-1-—á–∞—Å)
- [–≠—Ç–∞–ø 6: Scoring Engine](#—ç—Ç–∞–ø-6-scoring-engine-2-—á–∞—Å–∞)
- [–≠—Ç–∞–ø 7: Intent Detection](#—ç—Ç–∞–ø-7-intent-detection-2-—á–∞—Å–∞)
- [–≠—Ç–∞–ø 8: Smart Routing](#—ç—Ç–∞–ø-8-smart-routing-2-—á–∞—Å–∞)
- [–≠—Ç–∞–ø 9: Pipeline & Deals](#—ç—Ç–∞–ø-9-pipeline--deals-1-—á–∞—Å)
- [–≠—Ç–∞–ø 10: Automation Engine](#—ç—Ç–∞–ø-10-automation-engine-2-—á–∞—Å–∞)
- [–≠—Ç–∞–ø 11: Integrations](#—ç—Ç–∞–ø-11-integrations-slack-moco-1-—á–∞—Å)
- [–≠—Ç–∞–ø 12: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ](#—ç—Ç–∞–ø-12-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-1-—á–∞—Å)
- [–ß–µ–∫–ª–∏—Å—Ç –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏](#—á–µ–∫–ª–∏—Å—Ç-–≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏)

---

# –≠—Ç–∞–ø 0: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è (30 –º–∏–Ω—É—Ç)

## 0.1 –£—Å—Ç–∞–Ω–æ–≤–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –ü–û

```bash
# –ü—Ä–æ–≤–µ—Ä—å —á—Ç–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
node --version    # –ù—É–∂–µ–Ω v18+ (–ª—É—á—à–µ v20)
npm --version     # –ù—É–∂–µ–Ω v9+
docker --version  # –ù—É–∂–µ–Ω Docker Desktop
git --version     # –ù—É–∂–µ–Ω Git

# –£—Å—Ç–∞–Ω–æ–≤–∏ Cursor –µ—Å–ª–∏ –µ—â—ë –Ω–µ—Ç
# https://cursor.sh/ - —Å–∫–∞—á–∞–π –∏ —É—Å—Ç–∞–Ω–æ–≤–∏
```

## 0.2 –°–æ–∑–¥–∞–π —Ä–∞–±–æ—á—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é

```bash
# –°–æ–∑–¥–∞–π –ø–∞–ø–∫—É –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞
mkdir dna-marketing-engine
cd dna-marketing-engine

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π Git
git init
```

## 0.3 –°–∫–∞—á–∞–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é

–°–æ–∑–¥–∞–π –ø–∞–ø–∫—É `docs/` –∏ –ø–æ–ª–æ–∂–∏ —Ç—É–¥–∞ –æ–±–∞ —Ñ–∞–π–ª–∞ Master Prompt:
- `docs/MASTER_PROMPT_PART1.md`
- `docs/MASTER_PROMPT_PART2.md`

```bash
mkdir docs
# –°–∫–æ–ø–∏—Ä—É–π —Ñ–∞–π–ª—ã Master Prompt –≤ —ç—Ç—É –ø–∞–ø–∫—É
```

## 0.4 –û—Ç–∫—Ä–æ–π –ø—Ä–æ–µ–∫—Ç –≤ Cursor

```bash
cursor .
```

## 0.5 –ù–∞—Å—Ç—Ä–æ–π Cursor Rules

1. –û—Ç–∫—Ä–æ–π Settings: `Cmd+,` (Mac) / `Ctrl+,` (Windows)
2. –ù–∞–π–¥–∏ "Rules for AI"
3. –í—Å—Ç–∞–≤—å —ç—Ç–∏ –ø—Ä–∞–≤–∏–ª–∞:

```
# DNA Marketing Engine - Project Rules

## Project Context
Building a custom Marketing CRM with:
- Event-driven architecture (webhooks ‚Üí queue ‚Üí workers)
- Lead scoring with decay
- Intent detection (research/b2b/co_creation)
- Smart routing to pipelines
- No HubSpot - fully custom

## Tech Stack (ALWAYS USE)
- Runtime: Node.js 20 LTS
- Language: TypeScript (strict mode)
- Framework: Fastify (NOT Express)
- Database: PostgreSQL 15
- Queue: BullMQ with Redis
- Validation: Zod

## Code Style
- ES Modules (import/export, NOT require)
- Async/await (NOT callbacks)
- Proper error handling with try/catch
- Use 'pg' package for PostgreSQL (NOT Prisma, NOT Drizzle for now)
- File naming: camelCase.ts for files, PascalCase for classes

## Architecture Patterns
- Services: Business logic (scoringEngine.ts, leadService.ts)
- Workers: Background jobs (eventWorker.ts, routingWorker.ts)
- Routes: API endpoints (events.ts, leads.ts)
- Types: TypeScript interfaces (types/index.ts)

## Key Domain Concepts
- Lead starts in "Global Pool" (pipeline_id = NULL)
- Score = demographic + engagement + behavior
- Intent = research | b2b | co_creation (detected from events)
- Route when: score >= 40 AND intent_confidence >= 60%
```

‚úÖ **Checkpoint:** Cursor –æ—Ç–∫—Ä—ã—Ç, Rules –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã, docs/ –ø–∞–ø–∫–∞ —Å–æ–∑–¥–∞–Ω–∞

---

# –≠—Ç–∞–ø 1: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–µ–∫—Ç–∞ (1 —á–∞—Å)

## 1.1 –°–æ–∑–¥–∞–π —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–æ–µ–∫—Ç–∞

**–í Cursor Chat (Cmd+L), –Ω–∞–ø–∏—à–∏:**

```
Create the initial project structure for a Node.js TypeScript project.

Create these files:

1. package.json with:
   - name: "dna-marketing-engine"
   - type: "module"
   - scripts: dev, build, start, workers
   - dependencies: fastify, @fastify/cors, bullmq, ioredis, pg, zod, uuid, dayjs, pino, axios
   - devDependencies: typescript, @types/node, @types/pg, tsx, vitest

2. tsconfig.json with strict TypeScript, ES2022 target, NodeNext modules

3. .env.example with:
   - DATABASE_URL
   - REDIS_URL
   - PORT
   - WEBHOOK_SECRET
   - JWT_SECRET
   - SLACK_WEBHOOK_URL
   - MOCO_API_KEY
   - MOCO_SUBDOMAIN

4. .gitignore for Node.js project (node_modules, dist, .env, etc.)

5. Create empty folder structure:
   - src/api/routes/
   - src/api/middleware/
   - src/services/
   - src/workers/
   - src/integrations/
   - src/db/migrations/
   - src/config/
   - src/types/
```

## 1.2 –£—Å—Ç–∞–Ω–æ–≤–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

–ü–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ Cursor —Å–æ–∑–¥–∞—Å—Ç —Ñ–∞–π–ª—ã, –≤—ã–ø–æ–ª–Ω–∏ –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ:

```bash
npm install
```

## 1.3 –°–æ–∑–¥–∞–π .env —Ñ–∞–π–ª

```bash
cp .env.example .env
```

–û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π `.env`:

```bash
DATABASE_URL=postgres://dna:devpassword@localhost:5432/dna_marketing
REDIS_URL=redis://localhost:6379
PORT=3000
WEBHOOK_SECRET=dev_webhook_secret_32chars_min
JWT_SECRET=dev_jwt_secret_32characters_min
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/xxx/yyy/zzz
MOCO_API_KEY=your_moco_key
MOCO_SUBDOMAIN=your_company
```

## 1.4 –°–æ–∑–¥–∞–π docker-compose.yml

**–í Cursor Chat:**

```
Create docker-compose.yml with:
1. PostgreSQL 15 (postgres:15-alpine)
   - Database: dna_marketing
   - User: dna
   - Password: devpassword
   - Port: 5432
   - Volume for data persistence

2. Redis 7 (redis:7-alpine)
   - Port: 6379

Include healthchecks for both services.
```

## 1.5 –ó–∞–ø—É—Å—Ç–∏ Docker

```bash
docker-compose up -d

# –ü—Ä–æ–≤–µ—Ä—å —á—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
docker-compose ps
# –î–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–±–∞ —Å–µ—Ä–≤–∏—Å–∞ "Up"
```

‚úÖ **Checkpoint:** `npm install` –ø—Ä–æ—à—ë–ª, Docker –∑–∞–ø—É—â–µ–Ω, `.env` —Å–æ–∑–¥–∞–Ω

---

# –≠—Ç–∞–ø 2: –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö (1 —á–∞—Å)

## 2.1 –°–æ–∑–¥–∞–π –∫–æ–Ω—Ñ–∏–≥ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î

**–í Cursor Chat:**

```
Create src/config/index.ts that exports configuration object:
- Read all values from process.env
- Include: databaseUrl, redisUrl, port, webhookSecret, jwtSecret, slackWebhookUrl, mocoApiKey, mocoSubdomain
- Validate required vars, throw error if missing
```

## 2.2 –°–æ–∑–¥–∞–π –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL

**–í Cursor Chat:**

```
Create src/db/index.ts with PostgreSQL connection using 'pg' package:

1. Create Pool with connection string from config
2. Export helper functions:
   - query(sql, params) - execute query, return rows
   - queryOne(sql, params) - return first row or null
   - getClient() - get client for transactions

3. Add connection test on startup
4. Handle connection errors gracefully
```

## 2.3 –°–æ–∑–¥–∞–π –ø–æ–ª–Ω—É—é —Å—Ö–µ–º—É –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö

**–í Cursor Chat (—ç—Ç–æ –±–æ–ª—å—à–æ–π –ø—Ä–æ–º–ø—Ç):**

```
@docs/MASTER_PROMPT_PART1.md

Create src/db/migrations/001_initial_schema.sql with the complete database schema from Section 4.

Include ALL tables:
1. organizations
2. leads (with intent fields: primary_intent, intent_confidence, intent_summary, routing_status)
3. intent_signals
4. pipelines
5. pipeline_stages
6. deals
7. events (PARTITIONED BY RANGE on occurred_at)
8. scoring_rules
9. score_history
10. automation_rules
11. tasks
12. team_members

Include:
- All indexes from the document
- recalculate_lead_scores(lead_id) function
- expire_old_scores() function
- Event partitions for 2026 (Jan-Dec)

Also include SEED DATA:
- 4 pipelines: Discovery, Research Lab, B2B Lab Enablement, Panel Co-Creation
- All stages for each pipeline (from Section 3.2 of document)
```

## 2.4 –ü—Ä–∏–º–µ–Ω–∏ –º–∏–≥—Ä–∞—Ü–∏—é

```bash
# –ü–æ–¥–∫–ª—é—á–∏—Å—å –∫ PostgreSQL –∏ –≤—ã–ø–æ–ª–Ω–∏ –º–∏–≥—Ä–∞—Ü–∏—é
docker exec -i dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing < src/db/migrations/001_initial_schema.sql

# –ò–ª–∏ –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å –ª–æ–∫–∞–ª—å–Ω—ã–π psql:
psql $DATABASE_URL < src/db/migrations/001_initial_schema.sql
```

## 2.5 –ü—Ä–æ–≤–µ—Ä—å —á—Ç–æ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã

```bash
# –ü–æ–¥–∫–ª—é—á–∏—Å—å –∫ –ë–î
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing

# –í psql –≤—ã–ø–æ–ª–Ω–∏:
\dt
# –î–æ–ª–∂–µ–Ω –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã

SELECT * FROM pipelines;
# –î–æ–ª–∂–µ–Ω –ø–æ–∫–∞–∑–∞—Ç—å 4 pipeline

SELECT * FROM pipeline_stages;
# –î–æ–ª–∂–µ–Ω –ø–æ–∫–∞–∑–∞—Ç—å stages –¥–ª—è –∫–∞–∂–¥–æ–≥–æ pipeline

\q
# –í—ã—Ö–æ–¥
```

‚úÖ **Checkpoint:** –í—Å–µ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã, seed data –Ω–∞ –º–µ—Å—Ç–µ, pipelines –≤–∏–¥–Ω—ã

---

# –≠—Ç–∞–ø 3: –ë–∞–∑–æ–≤—ã–π API —Å–µ—Ä–≤–µ—Ä (1 —á–∞—Å)

## 3.1 –°–æ–∑–¥–∞–π TypeScript —Ç–∏–ø—ã

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART1.md

Create src/types/index.ts with all TypeScript types from Section 5:

Include:
1. Enums: EventSource, EventType, LeadStatus, LifecycleStage, RoutingStatus, IntentType, DealStatus, ScoreCategory

2. Core entities: Lead, Organization, Pipeline, PipelineStage, Deal, MarketingEvent

3. Intent types: IntentSignal, IntentSummary, IntentRule

4. Scoring types: ScoringRule, ScoreHistoryEntry

5. API types: IngestEventRequest, IngestEventResponse, LeadFilters, PaginatedResult

6. Job types: EventProcessingJob, ScoringJob, RoutingJob

Export all types.
```

## 3.2 –°–æ–∑–¥–∞–π Redis –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ

**–í Cursor Chat:**

```
Create src/config/redis.ts:
1. Import IORedis
2. Create and export Redis connection using REDIS_URL from config
3. Add connection event handlers (connect, error, close)
4. Export connection for BullMQ
```

## 3.3 –°–æ–∑–¥–∞–π Fastify —Å–µ—Ä–≤–µ—Ä

**–í Cursor Chat:**

```
Create src/index.ts - main entry point:

1. Import Fastify and plugins (@fastify/cors)
2. Import config and db
3. Create Fastify instance with logger (pino)
4. Register CORS
5. Add health check: GET /health
6. Add ready check: GET /ready (checks DB and Redis)
7. Import and register route modules (we'll create them next)
8. Start server on PORT from config
9. Handle graceful shutdown (SIGTERM, SIGINT)

Make sure to test database connection on startup.
```

## 3.4 –ó–∞–ø—É—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä –∏ –ø—Ä–æ–≤–µ—Ä—å

```bash
npm run dev
```

–í –¥—Ä—É–≥–æ–º —Ç–µ—Ä–º–∏–Ω–∞–ª–µ:
```bash
curl http://localhost:3000/health
# –û–∂–∏–¥–∞–µ–º: {"status":"ok"}

curl http://localhost:3000/ready
# –û–∂–∏–¥–∞–µ–º: {"status":"ready","database":"connected","redis":"connected"}
```

‚úÖ **Checkpoint:** –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è, health/ready endpoints —Ä–∞–±–æ—Ç–∞—é—Ç

---

# –≠—Ç–∞–ø 4: Event Ingestion (2 —á–∞—Å–∞)

## 4.1 –°–æ–∑–¥–∞–π HMAC middleware

**–í Cursor Chat:**

```
Create src/api/middleware/hmac.ts:

1. Export verifyHmacSignature middleware for Fastify
2. Read X-Webhook-Signature header
3. Calculate HMAC-SHA256 of raw request body using WEBHOOK_SECRET
4. Compare signatures (timing-safe comparison)
5. If invalid: return 401 Unauthorized
6. If valid: continue to handler

Also export helper function to generate signature (for testing).
```

## 4.2 –°–æ–∑–¥–∞–π BullMQ –æ—á–µ—Ä–µ–¥–∏

**–í Cursor Chat:**

```
Create src/config/queues.ts:

1. Import Queue from bullmq
2. Import redis connection
3. Create and export queues:
   - eventsQueue ('events')
   - scoringQueue ('scoring')
   - routingQueue ('routing')
   - syncQueue ('sync')
   - scheduledQueue ('scheduled')

4. Export queue names as constants
```

## 4.3 –°–æ–∑–¥–∞–π Event Ingestion endpoint

**–í Cursor Chat:**

```
Create src/api/routes/events.ts:

1. Create Fastify plugin that registers routes

2. POST /api/v1/events/ingest
   - Apply HMAC verification middleware
   - Validate body with Zod schema (IngestEventRequest):
     * event_type: enum of valid event types
     * source: enum of valid sources
     * occurred_at: ISO date string
     * lead_identifier: object with email?, linkedin_url?, portal_id?, waalaxy_id?
     * metadata?: object
     * correlation_id?: uuid string
     * campaign_id?: string
   - Generate event_id (uuid)
   - Add job to eventsQueue with event data
   - Return 202 Accepted with { event_id, status: 'queued', queued_at }

3. POST /api/v1/leads/bulk
   - For CSV/JSON batch import
   - Validate array of leads
   - Add batch job to eventsQueue
   - Return { job_id, leads_queued: count }

Include proper error handling and logging.
```

## 4.4 –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π routes –≤ —Å–µ—Ä–≤–µ—Ä–µ

**–í Cursor Chat:**

```
Update src/index.ts to:
1. Import eventsRoutes from './api/routes/events'
2. Register eventsRoutes with prefix '/api/v1'
```

## 4.5 –°–æ–∑–¥–∞–π Event Worker

**–í Cursor Chat:**

```
Create src/workers/eventWorker.ts:

1. Import Worker from bullmq
2. Import db, redis connection
3. Import types

4. Create worker for 'events' queue that processes jobs:

   async function processEvent(job):
     a. Extract: event_id, event_type, source, lead_identifier, metadata, occurred_at
     
     b. Find or create lead:
        - Try find by email first
        - Then by waalaxy_id, portal_id, linkedin_url
        - If not found, create new lead with routing_status='unrouted'
     
     c. Store event in events table
     
     d. Update lead's last_activity timestamp
     
     e. Update attribution:
        - If first event: set first_touch_source, first_touch_date
        - Always update last_touch_source, last_touch_date
     
     f. Add job to scoringQueue: { lead_id, event_id }
     
     g. Return processing result

5. Configure worker:
   - concurrency: 10
   - limiter: { max: 100, duration: 1000 }

6. Add event handlers: completed, failed, error

7. Export function to create and start worker
```

## 4.6 –°–æ–∑–¥–∞–π workers entry point

**–í Cursor Chat:**

```
Create src/workers/index.ts:

1. Import all worker creators
2. Import queue setup
3. Create main function that:
   - Initializes all workers
   - Sets up graceful shutdown
   - Logs startup
4. Call main() at the end
```

## 4.7 –î–æ–±–∞–≤—å npm script –¥–ª—è workers

–£–±–µ–¥–∏—Å—å —á—Ç–æ –≤ `package.json` –µ—Å—Ç—å:
```json
"scripts": {
  "dev:workers": "tsx watch src/workers/index.ts"
}
```

## 4.8 –¢–µ—Å—Ç–∏—Ä—É–π Event Ingestion

–¢–µ—Ä–º–∏–Ω–∞–ª 1:
```bash
npm run dev
```

–¢–µ—Ä–º–∏–Ω–∞–ª 2:
```bash
npm run dev:workers
```

–¢–µ—Ä–º–∏–Ω–∞–ª 3 - –æ—Ç–ø—Ä–∞–≤—å —Ç–µ—Å—Ç–æ–≤—ã–π event:
```bash
# –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π –ø–æ–¥–ø–∏—Å—å
BODY='{"event_type":"page_visited","source":"portal","occurred_at":"2026-01-21T12:00:00Z","lead_identifier":{"email":"test@example.com"},"metadata":{"page_path":"/pricing"}}'

SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)

curl -X POST http://localhost:3000/api/v1/events/ingest \
  -H "Content-Type: application/json" \
  -H "X-Webhook-Signature: $SIGNATURE" \
  -d "$BODY"
```

–û–∂–∏–¥–∞–µ–º—ã–π –æ—Ç–≤–µ—Ç:
```json
{"event_id":"...","status":"queued","queued_at":"..."}
```

–ü—Ä–æ–≤–µ—Ä—å –≤ –ë–î:
```bash
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "SELECT id, email, status FROM leads;"
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "SELECT id, event_type, source FROM events;"
```

‚úÖ **Checkpoint:** Events –ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è, leads —Å–æ–∑–¥–∞—é—Ç—Å—è, events –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è

---

# –≠—Ç–∞–ø 5: Lead Management (1 —á–∞—Å)

## 5.1 –°–æ–∑–¥–∞–π Lead Service

**–í Cursor Chat:**

```
Create src/services/leadService.ts:

Export class LeadService with methods:

1. findOrCreateLead(identifier: LeadIdentifier): Promise<Lead>
   - Try find by email, then waalaxy_id, portal_id, linkedin_url
   - If found, update any missing identifiers
   - If not found, create new lead
   - Return lead

2. getLeadById(id: string): Promise<Lead | null>

3. getLeadByEmail(email: string): Promise<Lead | null>

4. updateLead(id: string, data: Partial<Lead>): Promise<Lead>

5. searchLeads(filters: LeadFilters): Promise<PaginatedResult<Lead>>
   - Support filters: status, lifecycle_stage, routing_status, pipeline_id, primary_intent, min_score, max_score, search (full-text)
   - Support pagination: limit, offset
   - Return with total count

6. getLeadEvents(leadId: string, limit?: number): Promise<MarketingEvent[]>

7. getLeadScoreHistory(leadId: string): Promise<ScoreHistoryEntry[]>

8. deleteLead(id: string): Promise<void> (for GDPR)

Use db helper functions. Include proper error handling.
```

## 5.2 –°–æ–∑–¥–∞–π Leads API routes

**–í Cursor Chat:**

```
Create src/api/routes/leads.ts:

Fastify plugin with routes:

1. GET /api/v1/leads
   - Query params for filters (status, min_score, etc.)
   - Use leadService.searchLeads
   - Return paginated results

2. GET /api/v1/leads/unrouted
   - Get leads where routing_status = 'unrouted'
   - For marketing team to review

3. GET /api/v1/leads/:id
   - Get single lead with full details
   - Include organization if exists

4. POST /api/v1/leads
   - Manual lead creation
   - Validate with Zod
   - Use leadService

5. PATCH /api/v1/leads/:id
   - Update lead fields
   - Validate allowed fields

6. DELETE /api/v1/leads/:id
   - Soft delete or hard delete (GDPR)

7. GET /api/v1/leads/:id/events
   - Get lead's event timeline

8. GET /api/v1/leads/:id/scores
   - Get lead's score history

9. POST /api/v1/leads/:id/route
   - Manually route lead to pipeline
   - Body: { pipeline_slug, reason? }
```

## 5.3 –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π routes

**–í Cursor Chat:**

```
Update src/index.ts to register leadsRoutes
```

## 5.4 –¢–µ—Å—Ç–∏—Ä—É–π Lead API

```bash
# Get all leads
curl http://localhost:3000/api/v1/leads

# Get unrouted leads
curl http://localhost:3000/api/v1/leads/unrouted

# Get lead by ID (use ID from previous response)
curl http://localhost:3000/api/v1/leads/{lead_id}

# Search leads with score filter
curl "http://localhost:3000/api/v1/leads?min_score=10"
```

‚úÖ **Checkpoint:** Lead CRUD —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–æ–∏—Å–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç

---

# –≠—Ç–∞–ø 6: Scoring Engine (2 —á–∞—Å–∞)

## 6.1 –°–æ–∑–¥–∞–π –∫–æ–Ω—Ñ–∏–≥ scoring rules

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART1.md

Create src/config/scoringRules.ts with default scoring rules from Section 7:

Export array of ScoringRule objects:

ENGAGEMENT rules:
- page_visited: +2 pts, max 10/day, decay 30d
- page_visited (pricing): +5 pts, max 3/day, decay 30d
- roi_calculator_submitted: +15 pts, max 1/day, decay 60d
- demo_requested: +20 pts, max 1/day, decay 90d
- whitepaper_downloaded: +10 pts, max 3/day, decay 45d
- linkedin_profile_viewed: +3 pts, max 5/day, decay 14d
- linkedin_post_liked: +2 pts, max 5/day, decay 14d
- linkedin_post_commented: +5 pts, max 3/day, decay 21d
- email_opened: +1 pt, max 5/day, decay 14d
- email_link_clicked: +3 pts, max 3/day, decay 21d
- email_replied: +10 pts, max 1/day, decay 60d

BEHAVIOR rules:
- order_placed: +100 pts, no decay (converts to customer)
- user_registered: +25 pts, no decay

DEMOGRAPHIC rules (applied once based on lead/org fields):
- industry = Biotech/Pharma/Research: +20 pts
- company_size = 51-500: +10 pts
- job_title contains Lab Manager/Director/Head: +10 pts

Include function to seed rules to database if not exists.
```

## 6.2 –°–æ–∑–¥–∞–π Scoring Engine

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART1.md

Create src/services/scoringEngine.ts with ScoringEngine class:

Properties:
- rules: ScoringRule[] (loaded from DB)
- routingQueue: Queue (to trigger routing after score change)

Methods:

1. async loadRules(): Promise<void>
   - Load active rules from scoring_rules table
   - Sort by priority

2. async processEvent(event: MarketingEvent, lead: Lead): Promise<ScoringResult>
   - Find matching rules for this event
   - For each matching rule:
     * Check canApplyRule (rate limits)
     * If can apply: call applyScore
   - Recalculate lead scores (call DB function)
   - Check triggers (hot lead alerts)
   - Queue routing evaluation
   - Return result with rules_matched, points_added, new_scores

3. private matchesConditions(rule: ScoringRule, event: MarketingEvent, lead: Lead): boolean
   - For event_based rules: match event_type and metadata
   - For demographic rules: match lead/org fields
   - For behavior rules: execute complex queries

4. private async canApplyRule(rule: ScoringRule, leadId: string): Promise<boolean>
   - Check max_per_day: count today's applications
   - Check max_per_lead: count total applications
   - Return true if within limits

5. private async applyScore(rule: ScoringRule, leadId: string, eventId: string): Promise<void>
   - Calculate expires_at from decay_days
   - Insert into score_history
   - Update lead's denormalized scores

6. private async checkTriggers(leadId: string, oldScore: number, newScore: number): Promise<string[]>
   - If crossed 40: update lifecycle_stage to 'mql'
   - If crossed 80: update to 'sql', trigger hot_lead_alert
   - If crossed 120: trigger very_hot_lead_alert
   - Return list of triggered actions

Include proper logging.
```

## 6.3 –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–π Scoring –≤ Event Worker

**–í Cursor Chat:**

```
Update src/workers/eventWorker.ts:

1. Import ScoringEngine
2. Create scoringEngine instance in worker
3. After storing event and before finishing:
   - Call scoringEngine.processEvent(event, lead)
   - Log scoring result

The flow should be:
Event received ‚Üí Store event ‚Üí Update attribution ‚Üí Process scoring ‚Üí Queue routing
```

## 6.4 –°–æ–∑–¥–∞–π Scoring API routes

**–í Cursor Chat:**

```
Create src/api/routes/scoring.ts:

1. GET /api/v1/scoring/rules
   - List all scoring rules
   - Include is_active filter

2. POST /api/v1/scoring/rules
   - Create new scoring rule
   - Validate with Zod

3. PATCH /api/v1/scoring/rules/:id
   - Update rule (points, decay_days, is_active, etc.)

4. DELETE /api/v1/scoring/rules/:id
   - Soft delete (set is_active = false)

5. POST /api/v1/scoring/recalculate/:leadId
   - Manually recalculate lead's score
   - Useful after rule changes
```

## 6.5 Seed scoring rules

**–í Cursor Chat:**

```
Create src/db/seeds/scoring_rules.ts:

Script that inserts default scoring rules into database.
Check if rules exist before inserting (upsert by slug).
```

–í—ã–ø–æ–ª–Ω–∏:
```bash
npx tsx src/db/seeds/scoring_rules.ts
```

## 6.6 –¢–µ—Å—Ç–∏—Ä—É–π Scoring

```bash
# –û—Ç–ø—Ä–∞–≤—å –Ω–µ—Å–∫–æ–ª—å–∫–æ events –¥–ª—è –æ–¥–Ω–æ–≥–æ lead
BODY='{"event_type":"page_visited","source":"portal","occurred_at":"2026-01-21T12:00:00Z","lead_identifier":{"email":"scoring-test@example.com"},"metadata":{"page_path":"/pricing"}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# –û—Ç–ø—Ä–∞–≤—å –µ—â—ë –æ–¥–∏–Ω event
BODY='{"event_type":"roi_calculator_submitted","source":"portal","occurred_at":"2026-01-21T12:01:00Z","lead_identifier":{"email":"scoring-test@example.com"},"metadata":{}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# –ü—Ä–æ–≤–µ—Ä—å score –≤ –ë–î
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "SELECT email, engagement_score, total_score FROM leads WHERE email='scoring-test@example.com';"
```

‚úÖ **Checkpoint:** Scoring —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—á–∫–∏ –Ω–∞—á–∏—Å–ª—è—é—Ç—Å—è, score_history –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è

---

# –≠—Ç–∞–ø 7: Intent Detection (2 —á–∞—Å–∞)

## 7.1 –°–æ–∑–¥–∞–π –∫–æ–Ω—Ñ–∏–≥ Intent Rules

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART1.md

Create src/config/intentRules.ts with intent detection rules from Section 3.3:

Export array of IntentRule objects:

RESEARCH intent signals:
- page_visited /pricing/16s ‚Üí +25 pts
- email matches .edu, .ac., uni- ‚Üí +30 pts
- job_title contains PhD, PostDoc, Researcher, Professor ‚Üí +20 pts
- roi_calculator with samples < 100 ‚Üí +25 pts
- whitepaper download (protocol) ‚Üí +15 pts

B2B intent signals:
- page_visited /enterprise ‚Üí +30 pts
- roi_calculator submitted ‚Üí +20 pts
- roi_calculator with samples >= 100 ‚Üí +35 pts
- company_size 51+ employees ‚Üí +25 pts
- job_title contains Director, VP, Manager, Operations ‚Üí +20 pts
- page_visited /api-docs ‚Üí +25 pts
- whitepaper download (case-study) ‚Üí +20 pts

CO_CREATION intent signals:
- page_visited /partnerships ‚Üí +40 pts
- contact_form with inquiry_type=custom_panel ‚Üí +50 pts
- page_visited /white-label ‚Üí +45 pts
- industry Pharmaceutical, Biotech R&D ‚Üí +20 pts
- job_title contains VP, CSO, CTO, Chief, CEO, Founder ‚Üí +25 pts

Each rule should have:
- id: string
- intent: 'research' | 'b2b' | 'co_creation'
- trigger: object describing condition
- confidence_points: number
- description: string
```

## 7.2 –°–æ–∑–¥–∞–π Intent Detector Service

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART1.md

Create src/services/intentDetector.ts with IntentDetector class:

Properties:
- rules: IntentRule[]

Methods:

1. constructor()
   - Load rules from config

2. async processEvent(event: MarketingEvent, lead: Lead): Promise<IntentDetectionResult>
   - Find matching intent rules for this event
   - Store detected signals in intent_signals table
   - Recalculate lead's intent summary
   - Update lead's primary_intent and intent_confidence
   - Return result

3. private matchesIntentTrigger(rule: IntentRule, event: MarketingEvent, lead: Lead): boolean
   - For event triggers: match event_type and metadata
   - For lead_field triggers: check lead fields (email pattern, job_title)
   - For org_field triggers: check organization fields

4. async calculateIntentConfidence(leadId: string): Promise<IntentCalculation>
   - Get all intent_signals for lead
   - Sum points by intent type
   - Calculate primary_intent (highest score)
   - Calculate confidence (0-100):
     * confidence = (primary_score / total_points) * 100
     * Boost if primary clearly dominates secondary
     * Reduce if total signals are weak (< 30 pts)
   - Detect conflicts (two intents close in score)
   - Return { primary_intent, intent_confidence, intent_summary, is_routable, conflict_detected }

5. async updateLeadIntent(leadId: string, calculation: IntentCalculation): Promise<void>
   - Update lead's primary_intent, intent_confidence, intent_summary

Include the calculateIntentConfidence algorithm from Section 3.4 of the document.
```

## 7.3 –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–π Intent Detection –≤ Event Worker

**–í Cursor Chat:**

```
Update src/workers/eventWorker.ts:

1. Import IntentDetector
2. Create intentDetector instance
3. After scoring, call intentDetector.processEvent(event, lead)
4. Log intent detection results

Flow:
Event ‚Üí Store ‚Üí Attribution ‚Üí Scoring ‚Üí Intent Detection ‚Üí Queue Routing
```

## 7.4 –°–æ–∑–¥–∞–π API –¥–ª—è intent signals

**–í Cursor Chat:**

```
Update src/api/routes/leads.ts to add:

GET /api/v1/leads/:id/intents
- Get lead's intent signals
- Include calculated summary
```

## 7.5 –¢–µ—Å—Ç–∏—Ä—É–π Intent Detection

```bash
# –°–æ–∑–¥–∞–π lead —Å academic email (research intent)
BODY='{"event_type":"page_visited","source":"portal","occurred_at":"2026-01-21T12:00:00Z","lead_identifier":{"email":"professor@university.edu"},"metadata":{"page_path":"/pricing/16s"}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# –ü—Ä–æ–≤–µ—Ä—å intent
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "SELECT email, primary_intent, intent_confidence, intent_summary FROM leads WHERE email='professor@university.edu';"

# –°–æ–∑–¥–∞–π B2B lead
BODY='{"event_type":"roi_calculator_submitted","source":"portal","occurred_at":"2026-01-21T12:00:00Z","lead_identifier":{"email":"director@biotech-corp.com"},"metadata":{"samples_per_month":500}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# –ü—Ä–æ–≤–µ—Ä—å intent
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "SELECT email, primary_intent, intent_confidence FROM leads WHERE email='director@biotech-corp.com';"
```

‚úÖ **Checkpoint:** Intent detection —Ä–∞–±–æ—Ç–∞–µ—Ç, signals –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è, confidence —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è

---

# –≠—Ç–∞–ø 8: Smart Routing (2 —á–∞—Å–∞)

## 8.1 –°–æ–∑–¥–∞–π Routing Config

**–í Cursor Chat:**

```
Create src/config/routingConfig.ts:

Export ROUTING_CONFIG object:
- min_score_threshold: 40
- min_intent_confidence: 60
- intent_confidence_margin: 15
- max_unrouted_days: 14
- fallback_pipeline: 'discovery'
- owner_assignment:
  * research: { role: 'bdr', strategy: 'round_robin', region_aware: true }
  * b2b: { role: 'ae', strategy: 'capacity_based' }
  * co_creation: { role: 'partnership_manager', strategy: 'manual' }
  * discovery: { role: 'marketing_manager', strategy: 'notify_only' }
```

## 8.2 –°–æ–∑–¥–∞–π Pipeline Router Service

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART1.md

Create src/services/pipelineRouter.ts with PipelineRouter class:

This is the CRITICAL routing logic from Section 3.5.

Methods:

1. async evaluateAndRoute(lead: Lead): Promise<RoutingResult>
   - Skip if already routed (pipeline_id !== null)
   - Check minimum score threshold
   - Get intent calculation
   - If routable: call routeLeadToPipeline
   - If conflict: call handleIntentConflict
   - If stuck too long: call handleStuckLead
   - Otherwise: return wait

2. private async routeLeadToPipeline(lead: Lead, intent: IntentType): Promise<RoutingResult>
   - Map intent to pipeline slug:
     * research ‚Üí 'research-lab'
     * b2b ‚Üí 'b2b-lab-enablement'
     * co_creation ‚Üí 'panel-co-creation'
   - Get pipeline and first stage
   - Create deal in pipeline
   - Update lead: pipeline_id, routing_status='routed', routed_at
   - Assign owner based on config
   - Trigger notifications
   - Return result

3. private async handleIntentConflict(lead: Lead, intent: IntentCalculation): Promise<RoutingResult>
   - Send Slack notification with buttons
   - Return manual_review result

4. private async handleStuckLead(lead: Lead): Promise<RoutingResult>
   - Route to discovery pipeline
   - Notify marketing manager
   - Return result

5. private async assignOwner(lead: Lead, intent: IntentType): Promise<TeamMember | null>
   - Get assignment config for intent
   - If round_robin: get next available by role
   - If capacity_based: get least loaded
   - If manual: return null, just notify
   - Update team_member.current_leads
   - Return assigned member

6. Helper methods:
   - getLead(id)
   - getPipelineBySlug(slug)
   - getFirstStage(pipelineId)
   - createDeal(data)
   - updateLead(id, data)
   - sendSlackNotification(payload)
```

## 8.3 –°–æ–∑–¥–∞–π Routing Worker

**–í Cursor Chat:**

```
Create src/workers/routingWorker.ts:

1. Import Worker from bullmq
2. Create worker for 'routing' queue

3. Process job:
   - Get lead by id
   - Call pipelineRouter.evaluateAndRoute(lead)
   - Log result
   - Return result

4. Configure: concurrency 5

5. Export createRoutingWorker function
```

## 8.4 –û–±–Ω–æ–≤–∏ workers/index.ts

**–í Cursor Chat:**

```
Update src/workers/index.ts to include routingWorker
```

## 8.5 –î–æ–±–∞–≤—å routing –≤ Event Worker

**–í Cursor Chat:**

```
Update src/workers/eventWorker.ts:

After intent detection, add job to routingQueue:
routingQueue.add('evaluate', { lead_id: lead.id, trigger: 'event_processed' })
```

## 8.6 –°–æ–∑–¥–∞–π Routing API

**–í Cursor Chat:**

```
Create src/api/routes/routing.ts:

1. GET /api/v1/routing/config
   - Return current routing configuration

2. PUT /api/v1/routing/config
   - Update routing thresholds (admin only)

3. POST /api/v1/routing/evaluate/:leadId
   - Manually trigger routing evaluation
   - Useful for testing or manual intervention

4. GET /api/v1/routing/stats
   - Return routing statistics:
     * leads_routed_today
     * leads_by_pipeline
     * avg_time_to_route
     * conflicts_pending
```

## 8.7 –¢–µ—Å—Ç–∏—Ä—É–π Full Routing Flow

```bash
# –°–æ–∑–¥–∞–π lead —Å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º score –∏ intent –¥–ª—è routing
# –ù—É–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ events —á—Ç–æ–±—ã –Ω–∞–±—Ä–∞—Ç—å score >= 40

# Event 1: page visit
BODY='{"event_type":"page_visited","source":"portal","occurred_at":"2026-01-21T12:00:00Z","lead_identifier":{"email":"routing-test@company.com"},"metadata":{"page_path":"/pricing"}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# Event 2: ROI calculator (high volume = B2B)
BODY='{"event_type":"roi_calculator_submitted","source":"portal","occurred_at":"2026-01-21T12:01:00Z","lead_identifier":{"email":"routing-test@company.com"},"metadata":{"samples_per_month":200}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# Event 3: Demo request (+20 pts)
BODY='{"event_type":"demo_requested","source":"portal","occurred_at":"2026-01-21T12:02:00Z","lead_identifier":{"email":"routing-test@company.com"},"metadata":{}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# –ü—Ä–æ–≤–µ—Ä—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "SELECT email, total_score, primary_intent, intent_confidence, routing_status, pipeline_id FROM leads WHERE email='routing-test@company.com';"

# –ü—Ä–æ–≤–µ—Ä—å —Å–æ–∑–¥–∞–ª—Å—è –ª–∏ deal
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "SELECT d.id, d.name, p.name as pipeline, ps.name as stage FROM deals d JOIN pipelines p ON d.pipeline_id = p.id JOIN pipeline_stages ps ON d.stage_id = ps.id;"
```

‚úÖ **Checkpoint:** Full flow —Ä–∞–±–æ—Ç–∞–µ—Ç: Event ‚Üí Scoring ‚Üí Intent ‚Üí Routing ‚Üí Deal Created

---

# –≠—Ç–∞–ø 9: Pipeline & Deals (1 —á–∞—Å)

## 9.1 –°–æ–∑–¥–∞–π Pipeline Service

**–í Cursor Chat:**

```
Create src/services/pipelineService.ts:

Methods:
1. getAllPipelines(): Promise<Pipeline[]>
2. getPipelineById(id: string): Promise<Pipeline | null>
3. getPipelineBySlug(slug: string): Promise<Pipeline | null>
4. getPipelineWithStages(id: string): Promise<Pipeline & { stages: PipelineStage[] }>
5. getPipelineMetrics(id: string): Promise<PipelineMetrics>
   - deals_count by stage
   - total_value
   - avg_time_in_stage
   - conversion_rates
```

## 9.2 –°–æ–∑–¥–∞–π Deal Service

**–í Cursor Chat:**

```
Create src/services/dealService.ts:

Methods:
1. createDeal(data: CreateDealDTO): Promise<Deal>
2. getDealById(id: string): Promise<Deal | null>
3. getDealsByPipeline(pipelineId: string, filters?): Promise<Deal[]>
4. getDealsByLead(leadId: string): Promise<Deal[]>
5. updateDeal(id: string, data: Partial<Deal>): Promise<Deal>
6. moveDealToStage(dealId: string, stageId: string, reason?: string): Promise<Deal>
   - Update stage_id
   - Update stage_entered_at
   - Log stage change
7. closeDeal(dealId: string, status: 'won' | 'lost', reason?: string): Promise<Deal>
   - Update status, closed_at, close_reason
   - If won: update lead.lifecycle_stage to 'customer'
   - If won: queue Moco sync
```

## 9.3 –°–æ–∑–¥–∞–π Pipeline & Deal Routes

**–í Cursor Chat:**

```
Create src/api/routes/pipelines.ts:

1. GET /api/v1/pipelines - list all
2. GET /api/v1/pipelines/:id - get with stages
3. GET /api/v1/pipelines/:id/deals - deals in pipeline
4. GET /api/v1/pipelines/:id/metrics - funnel metrics

Create src/api/routes/deals.ts:

1. GET /api/v1/deals - list all (with filters)
2. GET /api/v1/deals/:id - get single
3. POST /api/v1/deals - create manually
4. PATCH /api/v1/deals/:id - update
5. POST /api/v1/deals/:id/move - move to stage
6. POST /api/v1/deals/:id/close - close deal
```

## 9.4 –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π routes

```
Update src/index.ts to register pipelines and deals routes
```

‚úÖ **Checkpoint:** Pipeline –∏ Deal CRUD —Ä–∞–±–æ—Ç–∞–µ—Ç

---

# –≠—Ç–∞–ø 10: Automation Engine (2 —á–∞—Å–∞)

## 10.1 –°–æ–∑–¥–∞–π Automation Engine

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART2.md

Create src/services/automationEngine.ts from Section 8:

Class AutomationEngine with methods:

1. loadRules(): Promise<void>

2. processEvent(lead: Lead, event: MarketingEvent): Promise<AutomationResult>
   - Find matching automation rules
   - Execute actions for each match
   - Return results

3. processStageChange(deal: Deal, fromStage: PipelineStage, toStage: PipelineStage): Promise<AutomationResult>
   - Run stage-specific automation

4. evaluateTrigger(rule: AutomationRule, lead: Lead, event?: MarketingEvent, deal?: Deal): boolean

5. executeAction(rule: AutomationRule, lead: Lead, event?: MarketingEvent, deal?: Deal): Promise<ActionResult>

Action implementations:
- actionMoveToStage
- actionAssignOwner
- actionSendNotification
- actionCreateTask
- actionSyncMoco
- actionUpdateField
- actionRouteToPipeline
```

## 10.2 –°–æ–∑–¥–∞–π Automation Rules seed

**–í Cursor Chat:**

```
Create src/db/seeds/automation_rules.ts:

Default automation rules:

1. Hot Lead Alert
   - Trigger: score_threshold >= 80
   - Action: send_notification to #hot-leads

2. Demo Requested ‚Üí Create Task
   - Trigger: event demo_requested
   - Action: create_task "Book demo call" due in 1 day

3. Order Placed ‚Üí Convert to Customer
   - Trigger: event order_placed
   - Action: update_field lifecycle_stage = 'customer'

4. B2B Intent Detected ‚Üí Assign AE
   - Trigger: intent_detected b2b with confidence >= 60
   - Action: assign_owner role=ae
```

## 10.3 –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–π –≤ Event Worker

**–í Cursor Chat:**

```
Update src/workers/eventWorker.ts:

After routing, call automationEngine.processEvent(lead, event)
```

## 10.4 –°–æ–∑–¥–∞–π Task Service & Routes

**–í Cursor Chat:**

```
Create src/services/taskService.ts:
- createTask
- getTasksByAssignee
- updateTask
- completeTask

Create src/api/routes/tasks.ts:
- GET /api/v1/tasks
- POST /api/v1/tasks
- PATCH /api/v1/tasks/:id
- POST /api/v1/tasks/:id/complete
```

‚úÖ **Checkpoint:** Automation rules –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è, tasks —Å–æ–∑–¥–∞—é—Ç—Å—è

---

# –≠—Ç–∞–ø 11: Integrations (Slack, Moco) (1 —á–∞—Å)

## 11.1 –°–æ–∑–¥–∞–π Slack Service

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART2.md

Create src/integrations/slack.ts from Section 10.2:

SlackService class with:
- sendMessage(channel, text)
- sendRichMessage(channel, blocks)
- sendHotLeadAlert(lead)
- sendRoutingConflict(lead)
- sendDailyDigest(stats)
```

## 11.2 –°–æ–∑–¥–∞–π Moco Service

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART2.md

Create src/integrations/moco.ts from Section 10.1:

MocoService class with:
- createCustomer(data)
- createOffer(data)
- createInvoiceFromOffer(offerId)
- getCustomer(id)
- findCustomerByEmail(email)
```

## 11.3 –°–æ–∑–¥–∞–π Sync Worker

**–í Cursor Chat:**

```
@docs/MASTER_PROMPT_PART2.md

Create src/workers/syncWorker.ts from Section 9.4:

Process sync jobs:
- moco: create_customer, create_offer, create_invoice
- slack: send notifications
```

## 11.4 –û–±–Ω–æ–≤–∏ workers/index.ts

**–í Cursor Chat:**

```
Update src/workers/index.ts to include syncWorker
```

‚úÖ **Checkpoint:** Slack notifications –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è, Moco sync —Ä–∞–±–æ—Ç–∞–µ—Ç

---

# –≠—Ç–∞–ø 12: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (1 —á–∞—Å)

## 12.1 End-to-End —Ç–µ—Å—Ç

–í—ã–ø–æ–ª–Ω–∏ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª:

```bash
# 1. –°–æ–∑–¥–∞–π –Ω–æ–≤–æ–≥–æ lead —á–µ—Ä–µ–∑ event
BODY='{"event_type":"page_visited","source":"waalaxy","occurred_at":"2026-01-21T12:00:00Z","lead_identifier":{"email":"e2e-test@biotech-startup.com","linkedin_url":"https://linkedin.com/in/testuser"},"metadata":{"page_path":"/"}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# 2. –î–æ–±–∞–≤—å engagement events
BODY='{"event_type":"page_visited","source":"portal","occurred_at":"2026-01-21T12:05:00Z","lead_identifier":{"email":"e2e-test@biotech-startup.com"},"metadata":{"page_path":"/enterprise"}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

BODY='{"event_type":"roi_calculator_submitted","source":"portal","occurred_at":"2026-01-21T12:10:00Z","lead_identifier":{"email":"e2e-test@biotech-startup.com"},"metadata":{"samples_per_month":300}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

BODY='{"event_type":"demo_requested","source":"portal","occurred_at":"2026-01-21T12:15:00Z","lead_identifier":{"email":"e2e-test@biotech-startup.com"},"metadata":{}}'
SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "dev_webhook_secret_32chars_min" | cut -d' ' -f2)
curl -X POST http://localhost:3000/api/v1/events/ingest -H "Content-Type: application/json" -H "X-Webhook-Signature: $SIGNATURE" -d "$BODY"

# 3. –ü–æ–¥–æ–∂–¥–∏ 5 —Å–µ–∫—É–Ω–¥ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
sleep 5

# 4. –ü—Ä–æ–≤–µ—Ä—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ API
curl http://localhost:3000/api/v1/leads | jq '.data[] | select(.email=="e2e-test@biotech-startup.com")'

# 5. –ü—Ä–æ–≤–µ—Ä—å –≤ –ë–î
docker exec -it dna-marketing-engine-postgres-1 psql -U dna -d dna_marketing -c "
SELECT 
  l.email, 
  l.total_score, 
  l.primary_intent, 
  l.intent_confidence,
  l.routing_status,
  p.name as pipeline,
  ps.name as stage
FROM leads l
LEFT JOIN pipelines p ON l.pipeline_id = p.id
LEFT JOIN deals d ON d.lead_id = l.id
LEFT JOIN pipeline_stages ps ON d.stage_id = ps.id
WHERE l.email = 'e2e-test@biotech-startup.com';
"
```

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
- total_score >= 40
- primary_intent = 'b2b'
- intent_confidence >= 60
- routing_status = 'routed'
- pipeline = 'B2B Lab Enablement'
- stage = 'Initial Contact' (first stage)

## 12.2 –ü—Ä–æ–≤–µ—Ä—å –≤—Å–µ endpoints

```bash
# Health & Ready
curl http://localhost:3000/health
curl http://localhost:3000/ready

# Leads
curl http://localhost:3000/api/v1/leads
curl http://localhost:3000/api/v1/leads/unrouted
curl "http://localhost:3000/api/v1/leads?min_score=20"

# Pipelines
curl http://localhost:3000/api/v1/pipelines
curl http://localhost:3000/api/v1/pipelines | jq '.[0].id' # get ID
curl http://localhost:3000/api/v1/pipelines/{pipeline_id}

# Deals
curl http://localhost:3000/api/v1/deals

# Scoring Rules
curl http://localhost:3000/api/v1/scoring/rules

# Routing
curl http://localhost:3000/api/v1/routing/config
```

‚úÖ **Checkpoint:** –í—Å–µ endpoints —Ä–∞–±–æ—Ç–∞—é—Ç, E2E flow –ø—Ä–æ—Ö–æ–¥–∏—Ç

---

# ‚úÖ –ß–µ–∫–ª–∏—Å—Ç –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏

## –ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞
- [ ] Docker running (postgres, redis)
- [ ] API server starts without errors
- [ ] Workers start without errors
- [ ] Database schema applied
- [ ] Seed data loaded (pipelines, scoring rules)

## Core Features
- [ ] Event ingestion works (POST /events/ingest)
- [ ] HMAC validation works
- [ ] Leads created from events
- [ ] Scoring engine calculates points
- [ ] Score history recorded
- [ ] Intent detection works
- [ ] Intent signals stored
- [ ] Routing evaluates correctly
- [ ] Deals created in correct pipeline
- [ ] Stage assignment works

## API Endpoints
- [ ] GET /health
- [ ] GET /ready
- [ ] POST /api/v1/events/ingest
- [ ] GET /api/v1/leads
- [ ] GET /api/v1/leads/:id
- [ ] GET /api/v1/pipelines
- [ ] GET /api/v1/deals
- [ ] GET /api/v1/scoring/rules

## Integrations
- [ ] Slack notifications (if configured)
- [ ] Moco sync (if configured)

---

# üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é!

–ï—Å–ª–∏ –≤—Å–µ —á–µ–∫–±–æ–∫—Å—ã –æ—Ç–º–µ—á–µ–Ω—ã - —É —Ç–µ–±—è —Ä–∞–±–æ—Ç–∞—é—â–∞—è CRM –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞!

**–°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:**
1. –î–æ–±–∞–≤—å UI (React/Next.js dashboard)
2. –ù–∞—Å—Ç—Ä–æ–π production deployment
3. –ü–æ–¥–∫–ª—é—á–∏ —Ä–µ–∞–ª—å–Ω—ã–µ webhook sources (Waalaxy, Lemlist)
4. –ù–∞—Å—Ç—Ä–æ–π Slack workspace
5. –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–π —Å Moco

---

**–í—Ä–µ–º—è –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ:** ~16-20 —á–∞—Å–æ–≤ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã  
**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –î–µ–ª–∞–π –ø–æ 2-3 —ç—Ç–∞–ø–∞ –≤ –¥–µ–Ω—å, —Ç–µ—Å—Ç–∏—Ä—É–π –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —ç—Ç–∞–ø–∞
